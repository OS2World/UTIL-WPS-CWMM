
/*
 * (C) Chris Wohlgemuth 2002-2004
 *
 */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; see the file COPYING.  If not, write to
 * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 */
/*
 * If you need another license for your project/product contact me at
 * 
 * http://www.os2world.com/cdwriting
 * http://www.geocities.com/SiliconValley/Sector/5785/
 */

/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using: 
 *      SOM Emitter emitctm: 2.42
 */

#ifndef SOM_Module_cwaudio_Source
#define SOM_Module_cwaudio_Source
#endif
#define CWAudio_Class_Source
#define M_CWAudio_Class_Source

#define INCL_PM
#define INCL_DOS
#define INCL_WINWORKPLACE
#define INCL_MMIOOS2
#define INCL_DOSDEVIOCTL
#define INCL_MCIOS2
#define  INCL_ERRORS

#include <os2.h>
#include <stdio.h>
#include "os2me.h"
#include "cwmmdataf.h"
#include "cwaudio.ih"
#include "except.h"
#include "cwaudioinc.h"
#include "cwmp3inc.h" /* */
#include "cwogginc.h" /* */
#include <wpdisk.h>
#include <wpfolder.h>

#include "ea_funcs.h" /* Functions to read and write EA of file system objects */
#include "som_wps_funcs.h"
#include "sys_funcs.h"


/* Redefine function names */
#define cwGetStringFromEA EARestoreString
#define cwSaveStringToEA EASaveString

char classDLLPath[CCHMAXPATH]={0};
char chrHelpLibrary[CCHMAXPATH]={0};
char chrInstallDir[CCHMAXPATH]={0};
char chrMMAudioExt[200]={0};/* Array holding the extensions for wpclsQueryInstanceFilter() */
char resDLLPath[CCHMAXPATH]={0};

static PSZ pszAudioColTitles[NUM_AUDIO_FIELDS]= {"Playtime", "Bitrate", "Samplerate", "Channels", "Bits per sample",
"Track Name","Artist","Album","Year","Comment","Genre"};

char chrPlayTime[SIZE_TITLE]="";
char chrBitRate[SIZE_TITLE]=""; /* New with 0.2.7 */
char chrSampleRate[SIZE_TITLE]="";
char chrChannels[SIZE_TITLE]="";
char chrBPS[SIZE_TITLE]="";
char chrName[SIZE_TITLE]="";
char chrArtist[SIZE_TITLE]="";
char chrAlbum[SIZE_TITLE]="";
char chrYear[SIZE_TITLE]="";
char chrComment[SIZE_TITLE]="";
char chrGenre[SIZE_TITLE]="";

static CLASSFIELDINFO cfiFieldInfo[NUM_AUDIO_FIELDS];

extern PMMFORMATINFO g_pmmFormatInfoArray; /* in cwimage.c */
extern LONG          lNumIOProcs;/* Needed to know how many convert menus we have */
int iRunningAudioFiles=0;        /* Used to check if there's already an audio file started */

extern char *genreList[];
extern int iGenreLast;

/* Global var with HAB */
extern HAB globalHab;

extern ULONG globalClassVolume;

HWND globalHwndObjectPlay;
MMAudio* globalObjectPlay;

BOOL globalHaveTimidity=0;

HMODULE queryModuleHandle(void);
HMODULE queryResModuleHandle(void);
PSZ queryModuleName(void);
BOOL getMessage(char* text,ULONG ulID, LONG lSizeText, HMODULE hResource,HWND hwnd);
ULONG messageBox( char* text, ULONG ulTextID , LONG lSizeText,
                  char* title, ULONG ulTitleID, LONG lSizeTitle,
                  HMODULE hResource, HWND hwnd, ULONG ulFlags);

void HlpSendCommandToObject(char* chrObject, char* command);
PSZ _queryMp3HelpLibraryName(void);
BOOL cwMoveNotebookButtonsWarp4(HWND hwndDlg, USHORT usID, USHORT usDelta);
BOOL cwObjectIsOnCD(WPObject * somSelf);
BOOL cwObjectIsOnInvalidDrive(WPObject * somSelf);
PSZ queryInstallDir(void);

BOOL mmclsSetObjectType(WPFileSystem * somSelf);
BOOL mmclsCreateTheDefaultTemplate(M_WPObject *somSelf, 
                                   WPObject* Folder);
ULONG launchPMProg(PSZ pszTitle, PSZ wrapperExe, PSZ parameters,  WPObject *thisPtr, ULONG ulView);
BOOL getStringFromRexxScript(PSZ rexxFile, char* chrResult, ULONG ulSize);

/* Max string length for the EA values e.g. the trackname. If this value is increased the
   retstring length in the REXX function handler rxCallCWMMFunc() must also be increased! */
#define MAX_EA_SIZE 256



static PBYTE _readTrackInfoIntoMem(MMAudio *somSelf, char * chrEAName, PBYTE pByte, ULONG ulSize)
{
  if(cwGetStringFromEA(somSelf, chrEAName , pByte, ulSize))
    {
      PBYTE pEAValue;
      ULONG ul, len;
      
      len=strlen(pByte);
      if( (pEAValue=_wpAllocMem(somSelf, len+1, &ul))!=NULLHANDLE) {
        strncpy(pEAValue, pByte, len);
        pEAValue[len]=0;
        return pEAValue;
      }
    }
  return NULLHANDLE;
}

void _fillEntryfieldsWithCurrentTrackNames( MMAudio *cwAudio, HWND hwnd)
{
  MMAudioData *somThis = MMAudioGetData(cwAudio);

  if(_pszName)
    WinSetWindowText(WinWindowFromID(hwnd,IDEF_ID3NAME), _pszName);
  else
    WinSetWindowText(WinWindowFromID(hwnd,IDEF_ID3NAME), "");

  if(_pszArtist)
    WinSetWindowText(WinWindowFromID(hwnd, IDEF_ID3ARTIST), _pszArtist);
  else
    WinSetWindowText(WinWindowFromID(hwnd, IDEF_ID3ARTIST), "");

  if(_pszAlbum)
    WinSetWindowText(WinWindowFromID(hwnd,IDEF_ID3ALBUM), _pszAlbum);
  else
    WinSetWindowText(WinWindowFromID(hwnd,IDEF_ID3ALBUM), "");

  if(_pszComment)
    WinSetWindowText(WinWindowFromID(hwnd, IDEF_ID3COMMENT), _pszComment);
  else
    WinSetWindowText(WinWindowFromID(hwnd, IDEF_ID3COMMENT), "");

  if(_pszYear)
    WinSetWindowText(WinWindowFromID(hwnd,IDEF_ID3YEAR), _pszYear);
  else
    WinSetWindowText(WinWindowFromID(hwnd,IDEF_ID3YEAR), "");

  if(_pszGenre)
    WinSetWindowText(WinWindowFromID(hwnd,IDDD_ID3GENRE), _pszGenre);
  else
    WinSetWindowText(WinWindowFromID(hwnd,IDDD_ID3GENRE), "");

#if 0
  if(_cwmmQueryTrackInfo(cwAudio, &chr, sizeof(tempChar), IDINFO_NAME))
    WinSetWindowText(WinWindowFromID(hwnd,IDEF_ID3NAME), chr);
  if(_cwmmQueryTrackInfo(cwAudio, &chr, sizeof(tempChar), IDINFO_ARTIST))
    WinSetWindowText(WinWindowFromID(hwnd, IDEF_ID3ARTIST),tempChar);
  if(_cwmmQueryTrackInfo(cwAudio, &chr, sizeof(tempChar), IDINFO_ALBUM))
    WinSetWindowText(WinWindowFromID(hwnd,IDEF_ID3ALBUM),tempChar);
  if(_cwmmQueryTrackInfo(cwAudio, &chr, sizeof(tempChar), IDINFO_COMMENT))
    WinSetWindowText(WinWindowFromID(hwnd, IDEF_ID3COMMENT),tempChar);
  if(_cwmmQueryTrackInfo(cwAudio, &chr, sizeof(tempChar), IDINFO_YEAR))
    WinSetWindowText(WinWindowFromID(hwnd,IDEF_ID3YEAR),tempChar);
  if(_cwmmQueryTrackInfo(cwAudio, &chr, sizeof(tempChar), IDINFO_GENRE))
    WinSetWindowText(WinWindowFromID(hwnd,IDDD_ID3GENRE),tempChar);
#endif
}

/****************************************************************/
/*                                                              */
/*                                                              */
/*                                                              */
/*                                                              */
/****************************************************************/
static PBYTE _readTrackInfoFromTextFieldIntoMem(MMAudio *somSelf, PBYTE pByte, HWND hwnd)
{
  ULONG ulLen;
  PBYTE pNewText;
  ULONG  ul;

  ulLen=WinQueryWindowTextLength(hwnd)+1;

  /* Alloc mem for new string */
  if( (pNewText=_wpAllocMem(somSelf, ulLen, &ul))!=NULLHANDLE) {
    WinQueryWindowText(hwnd, ulLen, pNewText);
    _wpFreeMem(somSelf, pByte);

    return pNewText;
  }

  return pByte;
}

/****************************************************************/
/*                                                              */
/* WNDPROC: trackNameDlgProc()                                  */
/*                                                              */
/* Window procedure handling the track information settings     */
/* page. The user may use the page to edit the information.     */
/*                                                              */
/****************************************************************/
static MRESULT EXPENTRY trackNameDlgProc(HWND hwnd, ULONG msg, MPARAM mp1, MPARAM mp2)
{
  MMAudio *cwAudio;


  switch(msg) {
  case WM_INITDLG :
    cwAudio=(MMAudio*)PVOIDFROMMP(mp2);

    WinSetWindowULong(WinWindowFromID(hwnd,IDEF_ID3NAME),
                      QWL_USER,(ULONG)cwAudio);//Save object ptr.

    if(somIsObj(cwAudio)) {
      int a;
      HWND hwndTemp;
      char name[50];
      MMAudioData *somThis = MMAudioGetData(cwAudio);
      /* Move default buttons on Warp 4 */
      cwMoveNotebookButtonsWarp4(hwnd, IDPB_ID3HELP, 15);

      if(!getMessage(name, IDSTR_TRACKNAME, sizeof(name),  queryResModuleHandle(), hwnd))
        strcpy(name, "Track name");
      WinSetWindowText(WinWindowFromID(hwnd,IDGB_ID3TAGS), name);

      WinSendMsg(WinWindowFromID(hwnd,IDEF_ID3NAME),EM_SETTEXTLIMIT,MPFROMSHORT((SHORT)MAX_EA_SIZE-1),0);
      WinSendMsg(WinWindowFromID(hwnd,IDEF_ID3ARTIST),EM_SETTEXTLIMIT,MPFROMSHORT((SHORT)MAX_EA_SIZE-1),0);
      WinSendMsg(WinWindowFromID(hwnd,IDEF_ID3ALBUM),EM_SETTEXTLIMIT,MPFROMSHORT((SHORT)MAX_EA_SIZE-1),0);
      WinSendMsg(WinWindowFromID(hwnd,IDEF_ID3COMMENT),EM_SETTEXTLIMIT,MPFROMSHORT((SHORT)MAX_EA_SIZE-1),0);
      WinSendMsg(WinWindowFromID(hwnd,IDEF_ID3YEAR),EM_SETTEXTLIMIT,MPFROMSHORT((SHORT)MAX_EA_SIZE-1),0);
      WinSendMsg(WinWindowFromID(hwnd,IDDD_ID3GENRE),EM_SETTEXTLIMIT,MPFROMSHORT((SHORT)MAX_EA_SIZE-1),0);
#if 0
      WinSendMsg(WinWindowFromID(hwnd,IDEF_ID3NAME),EM_SETTEXTLIMIT,MPFROMSHORT((SHORT)sizeof(_id3Name)-1),0);
      WinSendMsg(WinWindowFromID(hwnd,IDEF_ID3ARTIST),EM_SETTEXTLIMIT,MPFROMSHORT((SHORT)sizeof(_id3Artist)-1),0);
      WinSendMsg(WinWindowFromID(hwnd,IDEF_ID3ALBUM),EM_SETTEXTLIMIT,MPFROMSHORT((SHORT)sizeof(_id3Album)-1),0);
      WinSendMsg(WinWindowFromID(hwnd,IDEF_ID3COMMENT),EM_SETTEXTLIMIT,MPFROMSHORT((SHORT)sizeof(_id3Comment)-1),0);
      WinSendMsg(WinWindowFromID(hwnd,IDEF_ID3YEAR),EM_SETTEXTLIMIT,MPFROMSHORT((SHORT)sizeof(_id3Year)-1),0);
#endif      
      /* Fill drop downlist with knwon genres */
      hwndTemp=WinWindowFromID(hwnd, IDDD_ID3GENRE);
      for(a=0;a<=iGenreLast;a++)
        WinSendMsg(hwndTemp, LM_INSERTITEM, MPFROMSHORT(LIT_SORTASCENDING),MPFROMP(genreList[a]));
      _fillEntryfieldsWithCurrentTrackNames( cwAudio, hwnd);
    }
    WinSetWindowULong(WinQueryWindow(hwnd, QW_PARENT), QWL_HWNDFOCUSSAVE, hwnd);
    return (MRESULT)TRUE;
      /* This prevents switching the notebook page behind the open folder */
    case WM_WINDOWPOSCHANGED:
      {
        MRESULT mr;

        if(WinQueryFocus(HWND_DESKTOP)!=
           WinQueryWindow(WinQueryWindow(hwnd, QW_PARENT), QW_PARENT)) {
          mp2=MPFROMLONG(LONGFROMMP(mp2)|0x80000);/*AWP_ACTIVATE 0x00080000L*/
          mr=WinDefDlgProc(hwnd, msg, mp1, mp2);
          return mr;  
        }
        break;
      }
    case WM_FOCUSCHANGE:
      {
        if(!SHORT1FROMMP(mp2)) {
          if(HWNDFROMMP(mp1)==hwnd) {
            MRESULT mr;

            mr=WinDefDlgProc(hwnd, msg, mp1, mp2);
            WinSendMsg(WinQueryWindow(WinQueryWindow(hwnd, QW_PARENT), QW_PARENT), WM_SETFOCUS, MPFROMHWND(hwnd),
                       (MPARAM)TRUE);
            return mr;
          }
        }
        break;
      }
    case WM_DESTROY:
      /* The notebook closes and gets destroyed */
      /* Set focus to desktop to prevent PM freeze */
      WinSetFocus(HWND_DESKTOP, HWND_DESKTOP);
      break;
  case WM_COMMAND:
    cwAudio=(MMAudio*) WinQueryWindowULong(WinWindowFromID(hwnd, IDEF_ID3NAME),QWL_USER);
    if(somIsObj(cwAudio)) {
      switch(SHORT1FROMMP(mp1))
        {
        case IDPB_CANCEL:
          _fillEntryfieldsWithCurrentTrackNames( cwAudio, hwnd);
          break;
        case IDPB_ID3SAVE:
          {
            MMAudioData *somThis = MMAudioGetData(cwAudio);

            _pszName=_readTrackInfoFromTextFieldIntoMem(cwAudio, _pszName, WinWindowFromID(hwnd, IDEF_ID3NAME));
            _pszArtist=_readTrackInfoFromTextFieldIntoMem(cwAudio, _pszArtist, WinWindowFromID(hwnd, IDEF_ID3ARTIST));
            _pszAlbum=_readTrackInfoFromTextFieldIntoMem(cwAudio, _pszAlbum, WinWindowFromID(hwnd, IDEF_ID3ALBUM));
            _pszComment=_readTrackInfoFromTextFieldIntoMem(cwAudio, _pszComment, WinWindowFromID(hwnd, IDEF_ID3COMMENT));
            _pszYear=_readTrackInfoFromTextFieldIntoMem(cwAudio, _pszYear, WinWindowFromID(hwnd, IDEF_ID3YEAR));
            _pszGenre=_readTrackInfoFromTextFieldIntoMem(cwAudio, _pszGenre, WinWindowFromID(hwnd, IDDD_ID3GENRE));
            _wpSaveDeferred(cwAudio);
          }
          break;
        default:
          break;
        }
    }
    return (MRESULT) TRUE;
  default:
    break;
  }
  return WinDefDlgProc(hwnd, msg, mp1, mp2);
}

/****************************************************************/
/*                                                              */
/* METHOD: cwmmAddTrackNamePage()                               */
/*                                                              */
/* Insert new settings notebook page showing track information. */
/* The user may use this page to edit the information           */
/*                                                              */
/****************************************************************/
/*!*******************************************************/
/*                                                       */
/* @@DESC                                                */
/*                                                       */
/* This instance method is called to allow the object    */
/* to add the track name page to its Settings notebook.  */
/* :p.                                                   */
/* This page can be used to change the track information */
/* like title, album etc. which is stored in the EAs     */
/* of the file.                                          */
/*                                                       */
/* @@USAGE                                               */
/*                                                       */
/* This method must only be called from within an        */
/* override of wpAddSettingsPages().                     */
/*                                                       */
/* @@PARAM                                               */
/*                                                       */
/* MMAudio *somSelf input                                */
/*                                                       */
/* Pointer to the object on which the method is being    */
/* invoked.                                              */
/* :p.                                                   */
/* Points to an object of class :hp2.MMAudio:ehp2..      */
/*                                                       */
/* @@PARAM                                               */
/*                                                       */
/* HWND hwndNotebook input                               */
/*                                                       */
/* Settings notebook handle.                             */
/*                                                       */
/* @@OVERRIDE                                            */
/*                                                       */
/* This method should always be overridden in order to   */
/* remove or replace the image information page from     */
/* the object's Settings notbook.                        */
/* :p.                                                   */
/* To remove the page from the Settings notebook, the    */
/* override method should return                         */
/* :hp1.SETTINGS_PAGE_REMOVED:ehp1. without calling the  */
/* the parent method. To replace the page with another   */
/* page, the override method should call the             */
/* wpInsertSettingsPAge method without calling the       */
/* parent method.                                        */
/*                                                       */
/* @@RETURNS                                             */
/*                                                       */
/* ULONG rc                                              */
/*                                                       */
/* :parml compact tsize=15 break=none.                   */
/* :pt.0:pd.Error occurred                               */
/* :pt.PageId :pd.Identifier for the inserted page.      */
/* :eparml.                                              */
/*                                                       */
/*!!******************************************************/
SOM_Scope ULONG  SOMLINK cwaudio_cwmmAddTrackNamePage(MMAudio* somSelf, 
                                                      HWND hwndNotebook)
{
  PAGEINFO pageinfo;
  char pageName[100];

  /*    MMAudioData *somThis = MMAudioGetData(somSelf);*/
    MMAudioMethodDebug("MMAudio","cwaudio_cwmmAddTrackNamePage");

  //Clear the pageinfo structure
  memset((PCH)&pageinfo, 0, sizeof(PAGEINFO));
  //Fill the pageinfo structure
  pageinfo.cb = sizeof(PAGEINFO);
  pageinfo.hwndPage = NULLHANDLE;
  pageinfo.usPageStyleFlags = BKA_MAJOR | BKA_STATUSTEXTON;
  pageinfo.usPageInsertFlags = BKA_FIRST;
  //We want page numbers
  pageinfo.usSettingsFlags = SETTINGS_PAGE_NUMBERS;
  //The dialog procedure for this page
  pageinfo.pfnwp = trackNameDlgProc;
  //The resource DLL
  pageinfo.resid = queryResModuleHandle();
  //pageinfo.resid = queryModuleHandle();
  //The ID of the dialog template
  pageinfo.dlgid = IDDLG_ID3TAGS;
  //We need a pointer to our WPS-object in the dialog procedure
  //to call class functions
  pageinfo.pCreateParams = somSelf;
  //The ID of the help panel for this page
  pageinfo.idDefaultHelpPanel = TRACKNAME_SETTINGS_PANEL;
  //Tell the WPS the help library name
  pageinfo.pszHelpLibraryName = _queryMp3HelpLibraryName();
  //We have a major tab so we need a name
  if(!getMessage(pageName, ID_TRACKNAMEPAGENAME, sizeof(pageName), queryResModuleHandle(), hwndNotebook))
    strcpy(pageName, "~Track name");
  pageinfo.pszName = pageName;
  //Insert the page into the settings notebook

  return _wpInsertSettingsPage(somSelf,hwndNotebook,&pageinfo);
}

/* Remove all trailing spaces from a string. The string MUST be terminated by 0! */
void _removeTrailingSpaces(char * chrString)
{
  char *ptr;

  if((ptr=strrchr(chrString, 0))==NULLHANDLE)
    return;

  if(ptr==chrString)
    return;

  while(ptr>=chrString && (*ptr==0 || *ptr==' '))
    ptr--;

  *(++ptr)=0;
}


/****************************************************************/
/*                                                              */
/* WNDPROC: waveInfoDlgProc()                                   */
/*                                                              */
/* Window procedure handling the wave information settings      */
/* page.                                                        */
/*                                                              */
/****************************************************************/
MRESULT EXPENTRY waveInfoDlgProc(HWND hwnd, ULONG msg, MPARAM mp1, MPARAM mp2)
{
  MMAudio *cwAudio;

  switch(msg) {
  case WM_INITDLG :
    cwAudio=(MMAudio*)LONGFROMMP(mp2);
    if(somIsObj(cwAudio)) {
      char fName[CCHMAXPATH];
      MMAudioData *somThis = MMAudioGetData(cwAudio);
      
      sprintf(fName,"%d",_ulChannels);
      WinSetWindowText(WinWindowFromID(hwnd, IDST_CHANNELS),fName);
      
      sprintf(fName,"%d",_ulSampleRate);
      WinSetWindowText(WinWindowFromID(hwnd, IDST_SAMPLERATE),fName);
      sprintf(fName,"%d",_ulBPS);
      WinSetWindowText(WinWindowFromID(hwnd, IDST_BPS),fName);
      sprintf(fName,"%d:%02d",_ulPlaySecs/60, _ulPlaySecs%60);
      WinSetWindowText(WinWindowFromID(hwnd, IDST_PLAYTIME),fName);
      WinSetWindowULong(WinQueryWindow(hwnd, QW_PARENT), QWL_HWNDFOCUSSAVE, hwnd);
    }
    return (MRESULT)TRUE;
      /* This prevents switching the notebook page behind the open folder */
    case WM_WINDOWPOSCHANGED:
      {
        MRESULT mr;

        if(WinQueryFocus(HWND_DESKTOP)!=
           WinQueryWindow(WinQueryWindow(hwnd, QW_PARENT), QW_PARENT)) {
          mp2=MPFROMLONG(LONGFROMMP(mp2)|0x80000);/*AWP_ACTIVATE 0x00080000L*/
          mr=WinDefDlgProc(hwnd, msg, mp1, mp2);
          return mr;  
        }
        break;
      }
    case WM_FOCUSCHANGE:
      {
        if(!SHORT1FROMMP(mp2)) {
          if(HWNDFROMMP(mp1)==hwnd) {
            MRESULT mr;

            mr=WinDefDlgProc(hwnd, msg, mp1, mp2);
            WinSendMsg(WinQueryWindow(WinQueryWindow(hwnd, QW_PARENT), QW_PARENT), 
                       WM_SETFOCUS, MPFROMHWND(hwnd), (MPARAM)TRUE);
            return mr;
          }
        }
        break;
      }
    case WM_DESTROY:
      /* The notebook closes and gets destroyed */
      /* Set focus to desktop to prevent PM freeze */
      WinSetFocus(HWND_DESKTOP, HWND_DESKTOP);
      break;
  default:
    break;
  }
  return WinDefDlgProc(hwnd, msg, mp1, mp2);
}


/****************************************************************/
/*                                                              */
/* METHOD: cwmmAddAudioInformationPage()                        */
/*                                                              */
/* Insert new settings notebook page showing audio information. */
/*                                                              */
/****************************************************************/
/*!*******************************************************/
/*                                                       */
/* @@DESC                                                */
/*                                                       */
/* This instance method is called to allow the object    */
/* to add the audio information page to its Settings     */
/* notebook.                                             */
/*                                                       */
/* @@USAGE                                               */
/*                                                       */
/* This method must only be called from within an        */
/* override of wpAddSettingsPages().                     */
/*                                                       */
/* @@PARAM                                               */
/*                                                       */
/* MMAudio *somSelf input                                */
/*                                                       */
/* Pointer to the object on which the method is being    */
/* invoked.                                              */
/* :p.                                                   */
/* Points to an object of class :hp2.MMAudio:ehp2..      */
/*                                                       */
/* @@PARAM                                               */
/*                                                       */
/* HWND hwndNotebook input                               */
/*                                                       */
/* Settings notebook handle.                             */
/*                                                       */
/* @@OVERRIDE                                            */
/*                                                       */
/* This method should always be overridden in order to   */
/* remove or replace the image information page from     */
/* the object's Settings notbook.                        */
/* :p.                                                   */
/* To remove the page from the Settings notebook, the    */
/* override method should return                         */
/* :hp1.SETTINGS_PAGE_REMOVED:ehp1. without calling the  */
/* the parent method. To replace the page with another   */
/* page, the override method should call the             */
/* wpInsertSettingsPAge method without calling the       */
/* parent method.                                        */
/*                                                       */
/* @@RETURNS                                             */
/*                                                       */
/* ULONG rc                                              */
/*                                                       */
/* :parml compact tsize=15 break=none.                   */
/* :pt.0:pd.Error occurred                               */
/* :pt.PageId :pd.Identifier for the inserted page.      */
/* :eparml.                                              */
/*                                                       */
/*!!******************************************************/
SOM_Scope ULONG  SOMLINK cwaudio_cwmmAddAudioInformationPage(MMAudio* somSelf, 
                                                            HWND hwndNotebook)
{
  PAGEINFO pageinfo;
  char pageName[100];

  MMAudioData *somThis = MMAudioGetData(somSelf);
  MMAudioMethodDebug("MMAudio","cwaudio_cwmmAddWaveInformationPage");

  if(_ulFileSize!=_wpQueryFileSize(somSelf)) {
    /* The filesize changed, somebody altered the audio file so reread the info */
    /* Get class object */
    M_CWMMDataFile *m_cwmmDataFile=_CWMMDataFile;
    
    /* Send the object pointer to the audio worker thread to read the audio info in the background. */
    WinPostMsg(__get_hwndAudioWorker(_CWMMDataFile), WM_APPTERMINATENOTIFY, somSelf, 0);

#if 0
    /* The following is only important for MP3 files because gathering the audio info
       for MP3 files is currently very slow. Will improve with future releases of MMIOMP3*/
    if(!cwObjectIsOnCD(somSelf)) {
      /* Only get audio info when file isn't on CD. This speeds up opening of folders on CDs filled with
         MP3s. Doesn't hurt because folders of CDs open in normal details view as default so the audio info
         isn't necessary. When opening the settings notebook the info is reread anyway. */      
      
      /* Get class object */
      M_CWMMDataFile *m_cwmmDataFile=_CWMMDataFile;
      
      /* Send the object pointer to the audio worker thread to read the audio info in the background. */
      WinPostMsg(__get_hwndAudioWorker(_CWMMDataFile), WM_APPTERMINATENOTIFY, somSelf, 0);
    }
#endif
  }


  //Clear the pageinfo structure
  memset((PCH)&pageinfo, 0, sizeof(PAGEINFO));
  //Fill the pageinfo structure
  pageinfo.cb = sizeof(PAGEINFO);
  pageinfo.hwndPage = NULLHANDLE;
  pageinfo.usPageStyleFlags = BKA_MAJOR | BKA_STATUSTEXTON;
  pageinfo.usPageInsertFlags = BKA_FIRST;
  //We want page numbers
  pageinfo.usSettingsFlags = SETTINGS_PAGE_NUMBERS;
  //The dialog procedure for this page
  pageinfo.pfnwp = waveInfoDlgProc;
  //The resource DLL
  pageinfo.resid = queryResModuleHandle();
  //pageinfo.resid = queryModuleHandle();
  //The ID of the dialog template
  pageinfo.dlgid = IDDLG_WAVEINFOPAGE;
  //We need a pointer to our WPS-object in the dialog procedure
  //to call class functions
  pageinfo.pCreateParams = somSelf;
  //The ID of the help panel for this page
  //pageinfo.idDefaultHelpPanel = IDDLG_GENERAL2PAGE;
  //Tell the WPS the help library name
  pageinfo.pszHelpLibraryName = NULLHANDLE;
  //We have a major tab so we need a name
  if(!getMessage(pageName, ID_WAVEINFOPAGENAME, sizeof(pageName), queryResModuleHandle(), hwndNotebook))
    strcpy(pageName, "~Audio information");
  pageinfo.pszName = pageName;
  //Insert the page into the settings notebook
  return _wpInsertSettingsPage(somSelf,hwndNotebook,&pageinfo);
}

/*
 * The prototype for cwaudio_cwmmSetTrackInfo was replaced by the following prototype:
 */
SOM_Scope BOOL  SOMLINK cwaudio_cwmmSetTrackInfo(MMAudio *somSelf, 
                                                 char* chrString, 
                                                 ULONG ulValue, 
                                                 int iWhich)
{
  ULONG ulError;
    MMAudioData *somThis = MMAudioGetData(somSelf);
    MMAudioMethodDebug("MMAudio","cwaudio_cwmmSetIdInfo");

    if(iWhich<1||iWhich>IDINFO_LASTINFO)
      return FALSE;

    switch(iWhich)
      {
      case IDINFO_PLAYTIME:
        _ulPlaySecs=ulValue;
        sprintf(_chrPlayTime, "%02d:%02d",_ulPlaySecs/60, _ulPlaySecs%60);
        break;

      case IDINFO_BPS:
        _ulBPS=ulValue;
        sprintf(_chrBPS, "%d",_ulBPS);
        break;
      case IDINFO_CHANNELS:
        _ulChannels=ulValue;
        sprintf(_chrChannels, "%d",_ulChannels);
        break;
      case IDINFO_SAMPLERATE:
        _ulSampleRate=ulValue;
        sprintf(_chrSampleRate, "%d",_ulSampleRate);
        break;

      case IDINFO_NAME:
        {
          char chrEA[MAX_EA_SIZE];
          /* Make sure string isn't longer than defined EA size */
          my_strlcpy(chrEA, chrString, sizeof(chrEA));
          _pszName=somReallocString(somSelf, _pszName, chrEA, &ulError);
          //SysWriteToTrapLog("!! %s %d\n", __FUNCTION__, __LINE__);
          break;
        }
      case IDINFO_ARTIST:
        {
          char chrEA[MAX_EA_SIZE];
          my_strlcpy(chrEA, chrString, sizeof(chrEA));
          _pszArtist=somReallocString(somSelf, _pszArtist, chrEA, &ulError);
          break;
        }
      case IDINFO_ALBUM:
        {
          char chrEA[MAX_EA_SIZE];
          /* Make sure string isn't longer than defined EA size */
          my_strlcpy(chrEA, chrString, sizeof(chrEA));
          _pszAlbum=somReallocString(somSelf, _pszAlbum, chrEA, &ulError);
          break;
        }
      case IDINFO_YEAR:
        {
          char chrEA[MAX_EA_SIZE];
          /* Make sure string isn't longer than defined EA size */
          my_strlcpy(chrEA, chrString, sizeof(chrEA));
          _pszYear=somReallocString(somSelf, _pszYear, chrEA, &ulError);
          break;
        }
      case IDINFO_COMMENT:
        {
          char chrEA[MAX_EA_SIZE];
          /* Make sure string isn't longer than defined EA size */
          my_strlcpy(chrEA, chrString, sizeof(chrEA));
          _pszComment=somReallocString(somSelf, _pszComment, chrEA, &ulError);
          break;
        }
      case IDINFO_GENRE:
        {
          char chrEA[MAX_EA_SIZE];
          /* Make sure string isn't longer than defined EA size */
          my_strlcpy(chrEA, chrString, sizeof(chrEA));
          _pszGenre=somReallocString(somSelf, _pszGenre, chrEA, &ulError);
          break;
        }

#if 0
      case IDINFO_NAME:
        strncpy(_id3Name,chrString,sizeof(_id3Name));
        _id3Name[sizeof(_id3Name)-1]=0;
        _removeTrailingSpaces(_id3Name);
        break;
      case IDINFO_ARTIST:
        strncpy(_id3Artist,chrString,sizeof(_id3Artist));
        _id3Artist[sizeof(_id3Artist)-1]=0;
        _removeTrailingSpaces(_id3Artist);
        break;
      case IDINFO_ALBUM:
        strncpy(_id3Album, chrString, sizeof(_id3Album));
        _id3Album[sizeof(_id3Album)-1]=0;
        _removeTrailingSpaces(_id3Album);
        break;
      case IDINFO_YEAR:
        strncpy(_id3Year, chrString, sizeof(_id3Year));
        _id3Year[sizeof(_id3Year)-1]=0;
        _removeTrailingSpaces(_id3Year);
        break;
      case IDINFO_COMMENT:
        strncpy(_id3Comment,chrString, sizeof(_id3Comment));
        _id3Comment[sizeof(_id3Comment)]=0;
        _removeTrailingSpaces(_id3Comment);
        break;
      case IDINFO_GENRE:
        strncpy(_id3Genre, chrString, sizeof(_id3Genre));
        _id3Genre[sizeof(_id3Genre)-1]=0;
        _removeTrailingSpaces(_id3Genre);
        break;
#endif

      default:
        return FALSE;
      }

    /* Return statement to be customized: */
    return TRUE;
}


/*
 * The prototype for cwaudio_cwmmQueryTrackInfo was replaced by the following prototype:
 */

/*
 * SOM_Scope ULONG  SOMLINK cwaudio_cwmmQueryTrackInfo(MMAudio *somSelf, 
 *                                                     char** chrString, 
 *                                                     ULONG ulSize, 
 *                                                     int iWhich)
 */

/*
 * The prototype for cwaudio_cwmmQueryTrackInfo was replaced by the following prototype:
 */
/*!*******************************************************/
/*                                                       */
/* @@DESC                                                */
/*                                                       */
/* This instance method is called on an object when      */
/* information about the track is needed.                */
/*                                                       */
/*                                                       */
/* @@USAGE                                               */
/*                                                       */
/* This method can be called at any time in order to     */
/* get information about an audio object.                */
/* :p.                                                   */
/* The parameters :hp2.chrString:ehp2. and               */
/* :hp2.ulSize:ehp2. can be NULL if :hp2.iWhich:ehp2.    */
/* is one of the following                               */
/*                                                       */
/* :ul compact.                                          */
/* :li.IDINFO_PLAYTIME                                   */
/* :li.IDINFO_BPS                                        */
/* :li.IDINFO_CHANNELS                                   */
/* :li.IDINFO_SAMPLERATE                                 */
/* :li.IDINFO_BITRATE                                    */
/* :eul.                                                 */ 
/* :p.                                                   */
/* A numeric value is returned, for example the play     */
/* time.                                                 */
/* :p.                                                   */
/* For                                                   */
/*                                                       */
/* :ul compact.                                          */
/* :li.IDINFO_NAME                                       */
/* :li.IDINFO_ARTIST                                     */
/* :li.IDINFO_ALBUM                                      */
/* :li.IDINFO_COMMENT                                    */
/* :li.IDINFO_YEAR                                       */
/* :li.IDINFO_GENRE                                      */
/* :eul.                                                 */ 
/* :p.                                                   */
/* A string is copied into the buffer pointed to by      */
/* :hp2.chrString:ehp2.. At most ulSize-1 characters are */
/* copied. The string is terminated by a trailing 0.     */
/* :p.                                                   */
/* If both :hp2.chrString:ehp2. and :hp2.ulSize:ehp2.    */
/* are NULL the necessary buffersize for holding the     */
/* complete string (including the trailing 0) is         */
/* returned.                                             */
/*                                                       */
/* @@PARAM                                               */
/*                                                       */
/* MMAudio *somSelf input                                */
/*                                                       */
/* Pointer to the object on which the method is being    */
/* invoked.                                              */
/* :p.                                                   */
/* Points to an object of class :hp2.MMAudio:ehp2..      */
/*                                                       */
/* @@PARAM                                               */
/*                                                       */
/* PSZ chrString in/out                                  */
/*                                                       */
/* Pointer to a buffer receiving the information.        */
/* It is only used when querying a string. The returned  */
/* string is always terminated with 0.                   */
/*                                                       */
/* @@PARAM                                               */
/*                                                       */
/* ULONG ulSize input                                    */
/*                                                       */
/* Size of the buffer :hp2.chrString:ehp2..              */
/*                                                       */
/* @@PARAM                                               */
/*                                                       */
/* int iWhich input                                      */
/*                                                       */
/* Parameter specifying which information is queried.    */
/* :parml compact tsize=25 break=none.                   */
/* :pt.IDINFO_PLAYTIME                                   */        
/* :pd.The running time of the track in seconds.         */
/* :pt.IDINFO_BPS                                        */
/* :pd.Bits per sample.                                  */
/* :pt.IDINFO_CHANNELS                                   */
/* :pd.Number of channels. For MIDI files this is the    */
/*  number of MIDI tracks.                               */
/* :pt.IDINFO_SAMPLERATE                                 */
/* :pd.Samplerate                                        */
/* :pt.IDINFO_BITRATE                                    */
/* :pd.Bitrate                                           */
/* :pt.IDINFO_NAME                                       */
/* :pd.                                                  */
/* :pt.IDINFO_ARTIST                                     */
/* :pd.                                                  */
/* :pt.IDINFO_ALBUM                                      */
/* :pd.                                                  */
/* :pt.IDINFO_COMMENT                                    */
/* :pd.                                                  */
/* :pt.IDINFO_YEAR                                       */
/* :pd.                                                  */
/* :pt.IDINFO_GENRE                                      */
/* :pd.                                                  */
/* :eparml.                                              */
/*                                                       */
/* @@OVERRIDE                                            */
/*                                                       */
/* This method can be overriden by child classes if      */
/* such a class adds other information.                  */
/*                                                       */
/* @@RETURNS                                             */
/*                                                       */
/* ULONG rc                                              */
/*                                                       */
/* A numeric value for                                   */
/*                                                       */
/* :ul compact.                                          */
/* :li.IDINFO_PLAYTIME                                   */
/* :li.IDINFO_BPS                                        */
/* :li.IDINFO_CHANNELS                                   */
/* :li.IDINFO_SAMPLERATE                                 */
/* :li.IDINFO_BITRATE                                    */
/* :eul.                                                 */ 
/* :p.                                                   */
/*  0 indicates the information isn't available.         */
/* :p.                                                   */
/* For                                                   */
/*                                                       */
/* :ul compact.                                          */
/* :li.IDINFO_NAME                                       */
/* :li.IDINFO_ARTIST                                     */
/* :li.IDINFO_ALBUM                                      */
/* :li.IDINFO_COMMENT                                    */
/* :li.IDINFO_YEAR                                       */
/* :li.IDINFO_GENRE                                      */
/* :eul.                                                 */ 
/* :p.                                                   */
/* a return value of 0 indicates an error or the         */
/* information isn't available. A value <> 0 indicates   */
/* successful completion.                                */
/*!!******************************************************/
SOM_Scope ULONG  SOMLINK cwaudio_cwmmQueryTrackInfo(MMAudio *somSelf, 
                                                    PSZ chrString, 
                                                    ULONG ulSize, 
                                                    int iWhich)
{
  MMAudioData *somThis = MMAudioGetData(somSelf); 
    MMAudioMethodDebug("MMAudio","cwaudio_cwmmQueryTrackInfo");

    switch(iWhich)
      {
      case IDINFO_PLAYTIME:
        return _ulPlaySecs;
      case IDINFO_BPS:
        return _ulBPS;
      case IDINFO_CHANNELS:
        return _ulChannels;
      case IDINFO_SAMPLERATE:
        return _ulSampleRate;
      case IDINFO_BITRATE:
        return _ulBitRate;

      case IDINFO_NAME:
        {
          if(!_pszName) /* No information yet */
            return FALSE;
          /* Caller asks for buffer size */
          if(!chrString && ulSize==0)
            return strlen(_pszName)+1;
          if(!chrString)
            return 0;

          if(ulSize>strlen(_pszName)) {
            strcpy(chrString, _pszName);
          }
          else {
            strncpy(chrString, _pszName, ulSize);
            chrString[ulSize-1]=0;
          }
          if(chrString[0]==0)
            return FALSE;
          else
            return TRUE;
        }
      case IDINFO_ARTIST:
        {
          //    char *chr=*chrString;
          if(!_pszArtist)
            return FALSE;
          /* Caller asks for buffer size */
          if(!chrString && ulSize==0)
            return strlen(_pszArtist)+1;
          if(!chrString)
            return 0;

          if(ulSize>strlen(_pszArtist)) {
            strcpy(chrString, _pszArtist);
          }
          else {
            strncpy(chrString, _pszArtist, ulSize);
            chrString[ulSize-1]=0;
          }
          if(chrString[0]==0)
            return FALSE;
          else
            return TRUE;
        }
      case IDINFO_ALBUM:
        {
          //          char *chr=*chrString;
          if(!_pszAlbum)
            return FALSE;
          /* Caller asks for buffer size */
          if(!chrString && ulSize==0)
            return strlen(_pszAlbum)+1;
          if(!chrString)
            return 0;

          if(ulSize>strlen(_pszAlbum)) {
            strcpy(chrString, _pszAlbum);
          }
          else {
            strncpy(chrString, _pszAlbum, ulSize);
            chrString[ulSize-1]=0;
          }
          if(chrString[0]==0)
            return FALSE;
          else
            return TRUE;
        }
      case IDINFO_COMMENT:
        {
          //          char *chr=*chrString;
          if(!_pszComment)
            return FALSE;
          /* Caller asks for buffer size */
          if(!chrString && ulSize==0)
            return strlen(_pszComment)+1;
          if(!chrString)
            return 0;

          if(ulSize>strlen(_pszComment)) {
            strcpy(chrString, _pszComment);
          }
          else {
            strncpy(chrString, _pszComment, ulSize);
            chrString[ulSize-1]=0;
          }
          if(chrString[0]==0)
            return FALSE;
          else
            return TRUE;
        }
      case IDINFO_YEAR:
        {
          //          char *chr=*chrString;
          if(!_pszYear)
            return FALSE;
          /* Caller asks for buffer size */
          if(!chrString && ulSize==0)
            return strlen(_pszYear)+1;
          if(!chrString)
            return 0;

          if(ulSize>strlen(_pszYear)) {
            strcpy(chrString, _pszYear);
          }
          else {
            strncpy(chrString, _pszYear, ulSize);
            chrString[ulSize-1]=0;
          }
          if(chrString[0]==0)
            return FALSE;
          else
            return TRUE;
        }
      case IDINFO_GENRE:
        {
          //  char *chr=*chrString;
          if(!_pszGenre)
            return FALSE;
          /* Caller asks for buffer size */
          if(!chrString && ulSize==0)
            return strlen(_pszGenre)+1;
          if(!chrString)
            return 0;

          if(ulSize>=strlen(_pszGenre)) {
            strcpy(chrString, _pszGenre);
          }
          else {
            strncpy(chrString, _pszGenre, ulSize);
            chrString[ulSize-1]=0;
          }
          if(chrString[0]==0)
            return FALSE;
          else
            return TRUE;
        }

#if 0
      case IDINFO_NAME:
        {
          char *chr=*chrString;
          if(ulSize>=sizeof(_id3Name)) {
            strncpy(chr, _id3Name, sizeof(_id3Name));
            chr[sizeof(_id3Name)-1]=0;
          }
          else {
            strncpy(chr, _id3Name, ulSize);
            chr[ulSize-1]=0;
          }
          if(chr[0]==0)
            return FALSE;
          else
            return TRUE;
        }
      case IDINFO_ARTIST:
        {
          char *chr=*chrString;
          if(ulSize>=sizeof(_id3Artist)) {
            strncpy(chr, _id3Artist, sizeof(_id3Artist));
            chr[sizeof(_id3Artist)-1]=0;
          }
          else {
            strncpy(chr, _id3Artist, ulSize);
            chr[ulSize-1]=0;
          }
          if(chr[0]==0)
            return FALSE;
          else
            return TRUE;
        }
      case IDINFO_ALBUM:
        {
          char *chr=*chrString;
          if(ulSize>=sizeof(_id3Album)) {
            strncpy(chr, _id3Album, sizeof(_id3Album));
            chr[sizeof(_id3Album)-1]=0;
          }
          else {
            strncpy(chr, _id3Album, ulSize);
            chr[ulSize-1]=0;
          }
          if(chr[0]==0)
            return FALSE;
          else
            return TRUE;
        }
      case IDINFO_COMMENT:
        {
          char *chr=*chrString;
          if(ulSize>=sizeof(_id3Comment)) {
            strncpy(chr, _id3Comment, sizeof(_id3Comment));
            chr[sizeof(_id3Comment)-1]=0;
          }
          else {
            strncpy(chr, _id3Comment, ulSize);
            chr[ulSize-1]=0;
          }
          if(chr[0]==0)
            return FALSE;
          else
            return TRUE;
        }
      case IDINFO_YEAR:
        {
          char *chr=*chrString;
          if(ulSize>=sizeof(_id3Year)) {
            strncpy(chr, _id3Year, sizeof(_id3Year));
            chr[sizeof(_id3Year)-1]=0;
          }
          else {
            strncpy(chr, _id3Year, ulSize);
            chr[ulSize-1]=0;
          }
          if(chr[0]==0)
            return FALSE;
          else
            return TRUE;
        }
      case IDINFO_GENRE:
        {
          char *chr=*chrString;
          if(ulSize>=sizeof(_id3Genre)) {
            strncpy(chr, _id3Genre, sizeof(_id3Genre));
            chr[sizeof(_id3Genre)-1]=0;
          }
          else {
            strncpy(chr, _id3Genre, ulSize);
            chr[ulSize-1]=0;
          }
          if(chr[0]==0)
            return FALSE;
          else
            return TRUE;
        }
#endif

      default:
        break;
      }

    /* Return statement to be customized: */
    return 0;
}

/************************************************************/
/*                                                          */
/*                                                          */
/*                                                          */
/************************************************************/
MRESULT EXPENTRY playObjectProc(HWND hwnd, ULONG msg, MPARAM mp1, MPARAM mp2)
{

  switch (msg)
    {
    case WM_APPTERMINATENOTIFY:
      {
        if(LONGFROMMP(mp1)==ACKEY_START)
          {
            unsigned char chrCommand[CCHMAXPATH*2];
            char chrDevice[20];
            char name[CCHMAXPATH];
            ULONG ulNameSize;
            char retMsg[20];
            APIRET rc;
            int iTime;
            OPENPARAMS * pParams;
            MMAudio * thisPtr;
            
            pParams=PVOIDFROMMP(mp2);/* Get parameter block */
            if(!pParams)
              {
                WinPostMsg(hwnd,WM_QUIT,0,0);
                return MRFALSE;
              }
            
            WinSetWindowULong(hwnd, QWL_USER, (ULONG)pParams);

            thisPtr=pParams->wpObject;
            if(somIsObj(thisPtr)) {
              SOMClass* mmMIDIClass=somGetSomClass("MMMIDI");
              MMAudioData *somThis = MMAudioGetData(thisPtr);
                    
              if(_somIsA(thisPtr, mmMIDIClass))
                strncpy(chrDevice,"SEQUENCER", sizeof(chrDevice));
              else
                strncpy(chrDevice,"WAVEAUDIO", sizeof(chrDevice));
                    
              ulNameSize=sizeof(name);
              _wpQueryRealName(thisPtr, name, &ulNameSize, TRUE);
             
              /* Start audio file */  
              sprintf(chrCommand,"open \"%s\"  type %s alias wave%d SHAREABLE wait",name, chrDevice, thisPtr);
              rc = mciSendString( chrCommand, retMsg, sizeof(retMsg), hwnd, 0);
              if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
                WinPostMsg(hwnd,WM_QUIT,0,0);
                return MRFALSE;
              }

              /* Set time format */
              sprintf(chrCommand,"SET wave%d TIME FORMAT MILLISECONDS wait", thisPtr);
              rc = mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
              if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
                WinPostMsg(hwnd, WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_STOP), MPFROMP(thisPtr));
                return MRFALSE;
              }
                    
              sprintf(chrCommand,"STATUS wave%d LENGTH WAIT", thisPtr);
              rc = mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
              if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
                WinPostMsg(hwnd, WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_STOP), MPFROMP(thisPtr));
                return MRFALSE;
              }
                    
              iTime=atoi(retMsg);
                    
              //   sprintf(chrCommand,"SETPOSITIONADVISE wave%d ON EVERY %d NOTIFY", thisPtr, 3000);
              //   rc = mciSendString(chrCommand, retMsg, sizeof(retMsg), hwnd, 0);
                    
              if(iTime>1100)
                iTime-=700;
              else
                iTime-=300;
                    
              if(iTime<=0)
                iTime=100;
                    
              sprintf(chrCommand,"SETCUEPOINT wave%d ON at %d WAIT", thisPtr, iTime);
              rc = mciSendString(chrCommand, retMsg, sizeof(retMsg), hwnd, 0);
              if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
                WinPostMsg(hwnd, WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_STOP), MPFROMP(thisPtr));
                return MRFALSE;
              }
                
              /* Set volume */
              sprintf(chrCommand,"SET wave%d AUDIO VOLUME %d wait", thisPtr, globalClassVolume);
              rc = mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
              /* Not able to set the volume isn't that bad so don't quit in case of an error. */
#if 0
              if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
                WinPostMsg(hwnd, WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_STOP), MPFROMP(thisPtr));
                return MRFALSE;
              }
#endif

              WinStartTimer(WinQueryAnchorBlock(hwnd), hwnd, 1, 100);
                    
              sprintf(chrCommand,"play wave%d ", thisPtr);
              rc = mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
              if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
                WinPostMsg(hwnd, WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_STOP), MPFROMP(thisPtr));
                return MRFALSE;
              }
                    
              /* Set Time in icon title to 00:00 */
              strncpy(chrCommand, _wpQueryTitle(thisPtr), CCHMAXPATH);
              if(_ulPlaySecs) {
                sprintf(retMsg, "%02d:%02d", _ulPlaySecs/60, _ulPlaySecs%60);                  
                strncat(chrCommand,"\n00:00 / ",sizeof(chrCommand)-1-strlen(chrCommand));
                strncat(chrCommand, retMsg,sizeof(chrCommand)-1-strlen(chrCommand));
              }
              else
                strncat(chrCommand,"\n00:00", sizeof(chrCommand)-1-strlen(chrCommand));

              _cwmmSetRecordTitles(thisPtr, chrCommand, FALSE);
              WinStartTimer(WinQueryAnchorBlock(hwnd), hwnd, 1, 1000);
              __set_ulTrackStatus( thisPtr,TRACK_STATUS_PLAYING);
              break;
            }/* somIsObj(thisPtr) */
          }
        else
          {
            MMAudio * thisPtr;

            /* Don't use parameter block here (see AVKEY_PLAY handling). The param is
             indeed somSelf. */
            thisPtr=(MMAudio *)PVOIDFROMMP(mp2);/* Get object ptr */
            if(somIsObj(thisPtr)) {
              switch(LONGFROMMP(mp1))
                {
                case ACKEY_VOLUME:
                  {
                    HWND globalHwndObjectPlay;
                    unsigned char chrCommand[CCHMAXPATH];
                    char retMsg[20];

                    /* Set volume */
                    sprintf(chrCommand,"SET wave%d AUDIO VOLUME %d ", thisPtr, globalClassVolume);
                    mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
                    /* Not able to set the volume isn't that bad so don't quit in case of an error. */
                    break;
                  }
                case ACKEY_STOP:
                  {
                    /* Stop playing */
                    unsigned char chrCommand[CCHMAXPATH];
                    char retMsg[20];
                                      
                    WinStopTimer(WinQueryAnchorBlock(hwnd),hwnd,1 );
                    
                    sprintf(chrCommand,"stop wave%d wait", thisPtr);
                    mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
                    
                    sprintf(chrCommand,"close wave%d wait", thisPtr);
                    mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
                    
                    __set_ulTrackStatus(thisPtr, TRACK_STATUS_STOPPED);
                    WinPostMsg(hwnd,WM_QUIT,0,0);
                    break;
                  }
                case ACKEY_PAUSE:
                  {
                    unsigned char chrCommand[CCHMAXPATH];
                    char retMsg[20];
                    APIRET rc;
                    
                    sprintf(chrCommand,"STATUS wave%d MODE WAIT", thisPtr);
                    rc = mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
                    if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
                      WinPostMsg(hwnd, WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_STOP), MPFROMP(thisPtr));
                      return MRFALSE;
                    }
                    
                    if(!stricmp(retMsg, "playing"))
                      {
                        sprintf(chrCommand,"PAUSE wave%d wait", thisPtr);
                        rc=mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
                        if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
                          WinPostMsg(hwnd, WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_STOP), MPFROMP(thisPtr));
                          return MRFALSE;
                        }
                        __set_ulTrackStatus(thisPtr, TRACK_STATUS_PAUSED);
                      }
                    break;
                  }
                case ACKEY_RESUME:
                  {
                    unsigned char chrCommand[CCHMAXPATH];
                    char retMsg[20];
                    APIRET rc;
                    
                    sprintf(chrCommand,"STATUS wave%d MODE WAIT", thisPtr);
                    rc = mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
                    if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
                      WinPostMsg(hwnd, WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_STOP), MPFROMP(thisPtr));
                      return MRFALSE;
                    }
                                        
                    if(!stricmp(retMsg, "paused"))
                      {
                        sprintf(chrCommand,"RESUME wave%d wait", thisPtr);
                        rc=mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
                        if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
                          WinPostMsg(hwnd, WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_STOP), MPFROMP(thisPtr));
                          return MRFALSE;
                        }
                        __set_ulTrackStatus(thisPtr, TRACK_STATUS_PLAYING);
                      }
                    break;
                  }
                default:
                  break;
                }
            }/* if(thisPtr) */
            return MRFALSE;
          }
      }
      //case MM_MCIPOSITIONCHANGE:
    case WM_TIMER:
      if(SHORT1FROMMP(mp1)==1) {
        MMAudio * thisPtr;
        OPENPARAMS * pParams;

        pParams=(OPENPARAMS*)WinQueryWindowULong(hwnd, QWL_USER);
        thisPtr=pParams->wpObject;

        if(somIsObj(thisPtr)) {
          char retMsg[50];
          unsigned char chrCommand[CCHMAXPATH+20];
          APIRET rc;
          ULONG ulCur;
          MMAudioData *somThis = MMAudioGetData(thisPtr);


          /*@@CHANGE 0.2.8:

            Added check for hwndCnr==NULL, audio objects stopped playing after a second if not started from a folder.
            */
          /* Check if folder closed. If yes stop playing */
          if(pParams->hwndCnr && !WinIsWindow(globalHab, pParams->hwndCnr)) {
            WinPostMsg(hwnd, WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_STOP), MPFROMP(thisPtr));
            return MRFALSE;
          }
          /* Get current play position */
          sprintf(chrCommand,"STATUS wave%d POSITION WAIT", thisPtr);
          rc = mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
          if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
            return MRFALSE;
          }

          ulCur=atoi(retMsg);
          if(ulCur) {
           ulCur/=1000;
           if(!ulCur)
             ulCur=1;
          }

          strncpy(chrCommand, _wpQueryTitle(thisPtr), CCHMAXPATH);
          strncat(chrCommand,"\n",sizeof(chrCommand)-1-strlen(chrCommand));
          if(_ulPlaySecs) {
            sprintf(retMsg, "%02d:%02d / %02d:%02d", ulCur/60, ulCur%60, _ulPlaySecs/60, _ulPlaySecs%60);
            strncat(chrCommand, retMsg,sizeof(chrCommand)-1-strlen(chrCommand));
          }
          else
            {
            sprintf(retMsg, "%02d:%02d", ulCur/60, ulCur%60);
            strncat(chrCommand, retMsg,sizeof(chrCommand)-1-strlen(chrCommand));
            }
          if(_cwmmQueryTrackStatus(thisPtr)==TRACK_STATUS_PAUSED) {
            if(!getMessage(retMsg,  IDSTR_TRACKPAUSED, sizeof(retMsg), queryResModuleHandle(), HWND_DESKTOP))
              strcpy(retMsg," (Paused)");
            strncat(chrCommand, retMsg,sizeof(chrCommand)-1-strlen(chrCommand));
          }
          /* Set new time in icon title */
          _cwmmSetRecordTitles(thisPtr, chrCommand, FALSE);
        }
        return MRFALSE;
      }
      break;
    case MM_MCICUEPOINT:
      {
        /***********************************************/
        /* The track is about to end                   */
        /***********************************************/
        MMAudio * thisPtr;
        OPENPARAMS * pParams;
        pParams=(OPENPARAMS*)WinQueryWindowULong(hwnd, QWL_USER);
        thisPtr=pParams->wpObject;

        if(somIsObj(thisPtr)) {
          unsigned char chrCommand[CCHMAXPATH];
          char retMsg[20];

          sprintf(chrCommand,"STATUS wave%d MODE WAIT", thisPtr);
          do {
            APIRET rc;
            retMsg[0]=0;
            DosSleep(100);
            rc = mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
            if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
              WinPostMsg(hwnd, WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_STOP), MPFROMP(thisPtr));

              return MRFALSE;
            }
            //HlpWriteToTrapLog("%s\n", retMsg);
          } while(!stricmp(retMsg, "playing"));
          /* The track ended. Call 'Stop' so the object title is updated and everything is cleaned up. 
             During handling of the 'Stop' message the WM_QUIT message will be posted to end the thread. */
          WinPostMsg(hwnd, WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_STOP), MPFROMP(thisPtr));
        }
        return MRFALSE;
      }
    default:
      break;
    }
  return WinDefWindowProc( hwnd, msg, mp1, mp2);
}

/************************************************************/
/*                                                          */
/* This thread is used to handle the object in use emphasis.*/
/* Playing starts on the object window proc.                */
/*                                                          */
/************************************************************/
void _Optlink playThreadFunc (void *arg)
{
  HAB  hab;
  HMQ  hmq;
  QMSG qmsg;
  OPENPARAMS * params;
  CWMMDataFile *thisPtr;
  BOOL bCntDecremented=FALSE; /* Flag telling if the play counter was decremented so another audio file may be started. */

  params=(OPENPARAMS*)arg;
  if(!params) {
    iRunningAudioFiles--;
    if(iRunningAudioFiles<0)
      iRunningAudioFiles=0;/* Should never happen... */
    return;
  }

  thisPtr=params->wpObject; 
  if(!somIsObj(thisPtr)) {
    iRunningAudioFiles--;
    if(iRunningAudioFiles<0)
      iRunningAudioFiles=0;/* Should never happen... */
    _wpFreeMem(thisPtr, (PBYTE)params);
    return;
  }

  /* Prevent starting of several audio files at the same time */
  //if(iRunningAudioFiles<MAX_AUDIOFILE_STARTS+1) { 
    hab=WinInitialize(0);
    if(hab) {
      hmq=WinCreateMsgQueue(hab,0);
      if(hmq) {
        HWND hwnd;
        BOOL notFound;

        if(somIsObj(thisPtr)) {
          params->useItem.type=USAGE_OPENVIEW;
          params->viewItem.handle=NULLHANDLE;
          
          /* Create an invisible object window */
          hwnd=WinCreateWindow(HWND_OBJECT,WC_STATIC,"playObj", 0, 0, 0, 0, 0, 
                               NULLHANDLE, HWND_BOTTOM,12343,NULL,NULL);
          if(hwnd) {
            /* Window created. */
            /* Set in use emphasis for object */
            _wpAddToObjUseList(thisPtr, &params->useItem);

            /* Subclass the object window with the audio object private window proc.
               Every audio pbject has to set this in order to manage start/stop/resume command.
               It's usually done in MMAudio::wpInitData().  */
            WinSubclassWindow(hwnd, _cwmmQueryObjWindowProc(thisPtr));
            //SysWriteToTrapLog("WinSubclassWindow() returned: %x\n_cwmmQueryObjWindowProc() returns: %x\nplayObjectProc: %x\n",
            //WinSubclassWindow(hwnd, _cwmmQueryObjWindowProc(thisPtr)), _cwmmQueryObjWindowProc(thisPtr),playObjectProc);

            //  DosSetPriority(PRTYS_THREAD, PRTYC_FOREGROUNDSERVER, 0, 0);
            
            /* Tell the window proc to start the file */
            WinPostMsg(hwnd, WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_START), MPFROMP(params));

            /* Save object window pointer in instance data */
            __set_hwndObjectPlay(thisPtr, hwnd);
            /* Needed for volume setting */
            globalHwndObjectPlay=hwnd;
            globalObjectPlay=thisPtr;

            while(WinGetMsg(hab,&qmsg,(HWND)NULL,0,0))
              WinDispatchMsg(hab,&qmsg);
            WinDestroyWindow(hwnd);
            _cwmmSetRecordTitles(thisPtr, NULLHANDLE, FALSE);
          }
          if(somIsObj(thisPtr)) {
            /* Remove in use emphasis */
            _wpDeleteFromObjUseList(thisPtr, &params->useItem);

            __set_hwndObjectPlay(thisPtr, NULLHANDLE);

            _wpSetDefaultView(thisPtr, __get_ulPreviousView(thisPtr));
          }/* somIsObj() */

          iRunningAudioFiles--;
          if(iRunningAudioFiles<0)
            iRunningAudioFiles=0;/* Should never happen... */
          bCntDecremented=TRUE;

          /* The track ended. Check if there're other tracks selected in
             the container. If yes, start the next track. */
          notFound=TRUE;
          for(;;)
            {
              PMINIRECORDCORE pMrc, mrcTemp;
              OPENPARAMS * pParams;
              WPObject * contentObject;
              SOMClass *cwAudioClass=somGetSomClass("MMAudio");
        
              pParams=params;
        
              /* Get MINIRECORDCORE */
              if(!(pMrc=_wpQueryCoreRecord(thisPtr)))
                break;

              if(!WinIsWindow(WinQueryAnchorBlock(HWND_DESKTOP), pParams->hwndCnr))
                break; /* Container isn't valid. Probably the folder was closed. */

              /* Remove selected state if any */
              WinSendMsg(pParams->hwndCnr, CM_SETRECORDEMPHASIS, MPFROMP(pMrc), MPFROM2SHORT(FALSE, CRA_SELECTED));

              /* Get next selected audio file */
              mrcTemp=(PMINIRECORDCORE)WinSendMsg(pParams->hwndCnr,CM_QUERYRECORDEMPHASIS, pMrc,
                                                  MPFROMSHORT(CRA_SELECTED));
              if((int)mrcTemp==-1) 
                /* Wrong parameter -> user deleted the shadow. */
                break;
        
              /* No selected files after the currently playing one. So start at the beginnning of the
                 container. */
              if(!mrcTemp)
                mrcTemp=(PMINIRECORDCORE)WinSendMsg(pParams->hwndCnr,CM_QUERYRECORDEMPHASIS, (MPARAM)CMA_FIRST,
                                                    MPFROMSHORT(CRA_SELECTED));

              while(notFound && mrcTemp && (int)mrcTemp!=-1){
                contentObject=(WPObject*)OBJECT_FROM_PREC(mrcTemp);//Get object
                if(somIsObj(contentObject)) {
                  /* Get file system object or NULL */
                  if((contentObject=somGetFileSystemObject(contentObject))==NULLHANDLE) {
                    mrcTemp=(PMINIRECORDCORE)WinSendMsg(pParams->hwndCnr,CM_QUERYRECORDEMPHASIS, mrcTemp,
                                                        MPFROMSHORT(CRA_SELECTED));
                    continue;
                  }
                }
                else
                  break;/* Error */
          
                if(_somIsA(contentObject, cwAudioClass)) {
                  notFound=FALSE;
                }
                else
                  {
                    /* Try next object */
                    mrcTemp=(PMINIRECORDCORE)WinSendMsg(pParams->hwndCnr,CM_QUERYRECORDEMPHASIS, mrcTemp,
                                                        MPFROMSHORT(CRA_SELECTED));
                  }
              }; /* while */
              if(notFound)
                break;
              /* Another audio file is selected. Start it. */
              _wpViewObject(contentObject, params->hwndCnr, ID_MENU_START, NULLHANDLE);
              break;
            }; /* for() */
          /* FIXME
             Get thread sync right.

             Set global handle to NULL if no more files to play. Doing it this way we prevent a race condition
             with the newly started thread. Not really nice but simple. A mutex wouldn't help because we must
             prevent that this ending thread overwrites the handle which may be set by the newly started thread. */
          if(notFound) {
            globalHwndObjectPlay=NULLHANDLE;
            globalObjectPlay=NULLHANDLE;
          }
        }/* somIsObj() */
        WinDestroyMsgQueue(hmq);
      }
      WinTerminate(hab);
    }/* hab */
    //  }/* iRunningAudioFiles */

    if(!bCntDecremented) {
      iRunningAudioFiles--;
      if(iRunningAudioFiles<0)
        iRunningAudioFiles=0;/* Should never happen... */
    }
  /* Free the parameter block */
  _wpFreeMem(thisPtr, (PBYTE)params);
}

/****************************************************************/
/*                                                              */
/* New method which starts playing of the file. Playing is done */
/* on a separate thread.                                        */
/*                                                              */
/****************************************************************/
/*!*******************************************************/
/*                                                       */
/* @@DESC                                                */
/*                                                       */
/* This instance method is called to allow the object    */
/* to start or stop audio playing.                       */
/*                                                       */
/*                                                       */
/* @@USAGE                                               */
/*                                                       */
/* This method can be called at any time in order to     */
/* start or stop playing.                                */
/* :p.                                                   */
/* The audio file is played on a separate thread. In use */
/* emphasis is applied and the current playing time      */
/* will be shown in the objects title.                   */
/*                                                       */
/* @@PARAM                                               */
/*                                                       */
/* MMAudio *somSelf input                                */
/*                                                       */
/* Pointer to the object on which the method is being    */
/* invoked.                                              */
/* :p.                                                   */
/* Points to an object of class :hp2.MMAudio:ehp2..      */
/*                                                       */
/* @@PARAM                                               */
/*                                                       */
/* HWND hwndCnr input                                    */
/*                                                       */
/* Handle of the container which holds the object.       */
/*                                                       */
/* @@PARAM                                               */
/*                                                       */
/* BOOL bPlay input                                      */
/*                                                       */
/* Start/stop flag.                                      */
/* :p.                                                   */
/* If TRUE the object will start playing.                */
/* :p.                                                   */
/* If FALSE a playing object stops playing.              */
/*                                                       */
/* @@OVERRIDE                                            */
/*                                                       */
/* This method is usually not overriden.                 */
/*                                                       */
/* @@REMARKS                                             */
/*                                                       */
/* This method does not have a return value.             */
/* The only way to check if the method succeeded is      */
/* to use the method cwmmQueryTrackStatus().             */
/* :p.                                                   */
/* This is because control is given to a new thread      */
/* and it's not clear at which time this new thread will */
/* start execution.                                      */ 
/*                                                       */
/*!!******************************************************/
SOM_Scope void  SOMLINK cwaudio_cwmmPlayTrack(MMAudio* somSelf, 
                                              HWND hwndCnr, BOOL bPlay)
{
  ULONG ulError;
  OPENPARAMS *pThreadParams;

    MMAudioMethodDebug("MMAudio","cwaudio_cwmmPlayTrack");

    if(bPlay) { /* Start playing */
      /* Check if there's a valid object window for handling the play messages. */
      if(!WinIsWindow(WinQueryAnchorBlock(HWND_DESKTOP),__get_hwndObjectPlay(somSelf))) {
        /* Start playing only if there's not an object window yet. This is only
           a sanity check. If there's already an object window the track already is
           started.
           */
        pThreadParams=(OPENPARAMS*)_wpAllocMem(somSelf, sizeof(OPENPARAMS), &ulError);
        if(pThreadParams) {
          char chrTitle[CCHMAXPATH];
          char chrText[100];

          strncpy(chrTitle, _wpQueryTitle(somSelf), sizeof(chrTitle));
          chrTitle[sizeof(chrTitle)-1]=0;
          if(!getMessage(chrText, IDSTR_STARTINGTRACK, sizeof(chrText), queryResModuleHandle(), HWND_DESKTOP))
            strcpy(chrText, "Starting Track...");;
          strncat(chrTitle,"\n", sizeof(chrTitle)-1-strlen(chrTitle));
          strncat(chrTitle, chrText, sizeof(chrTitle)-1-strlen(chrTitle));

          memset((void*)pThreadParams ,0, sizeof(OPENPARAMS));
          pThreadParams->wpObject=somSelf;
          pThreadParams->hwndCnr=hwndCnr;
          pThreadParams->viewItem.view=ID_MENU_START;
          if(_beginthread(playThreadFunc,NULL,8192*160,(void*)pThreadParams)) //Fehlerbehandlung fehlt
            _cwmmSetRecordTitles(somSelf, chrTitle, FALSE);
        }
      }
    }
    else /* Stop playing. */
      if(WinIsWindow(WinQueryAnchorBlock(HWND_DESKTOP),__get_hwndObjectPlay(somSelf)))
        WinPostMsg(__get_hwndObjectPlay(somSelf), WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_STOP), MPFROMP(somSelf));
}



/*
  This method is called to pause a playing track from the context menu.
*/
/*
 *    LONG  cwmmSetTrackVolume(in ULONG ulVolume);
 *    LONG  cwmmQueryTrackVolume();
 */

/*
 *    LONG  cwmmSetTrackVolume(in ULONG ulVolume);
 *    LONG  cwmmQueryTrackVolume();
 * Local filesize info to check if someone altered the file. Attribute because MMMP3 needs this info.
 */
/*!*******************************************************/
/*                                                       */
/* @@DESC                                                */
/*                                                       */
/* This instance method is called to allow the object    */
/* to pause or resume audio playing.                     */
/*                                                       */
/*                                                       */
/* @@USAGE                                               */
/*                                                       */
/* This method can be called at any time in order to     */
/* control playing.                                      */
/*                                                       */
/* @@PARAM                                               */
/*                                                       */
/* MMAudio *somSelf input                                */
/*                                                       */
/* Pointer to the object on which the method is being    */
/* invoked.                                              */
/* :p.                                                   */
/* Points to an object of class :hp2.MMAudio:ehp2..      */
/*                                                       */
/* @@PARAM                                               */
/*                                                       */
/* HWND hwndCnr input                                    */
/*                                                       */
/* Handle of the container which holds the object.       */
/*                                                       */
/* @@PARAM                                               */
/*                                                       */
/* ULONG ulAction input                                  */
/*                                                       */
/* Pause/resume.                                         */
/* :parml compact tsize=25 break=none.                   */
/* :pt.ACKEY_PAUSE:pd.The object will pause playing.     */
/* :pt.ACKEY_RESUME:pd.A currently pausing object        */
/* resumes playing.                                      */
/* :eparml.                                              */
/* @@OVERRIDE                                            */
/*                                                       */
/* This method is usually not overriden.                 */
/*                                                       */
/* @@REMARKS                                             */
/*                                                       */
/* This method does not have a return value.             */
/* Use the method cwmmQueryTrackStatus() to check the    */ 
/* current state of the audio object.                    */
/*                                                       */
/*                                                       */
/*                                                       */
/*!!******************************************************/
SOM_Scope void  SOMLINK cwaudio_cwmmPauseTrack(MMAudio *somSelf, 
                                               HWND hwndCnr, 
                                               ULONG ulAction)
{
  /*    CWMMDataFileData *somThis = CWMMDataFileGetData(somSelf);*/
    MMAudioMethodDebug("MMAudio","cwaudio_cwmmPauseTrack");
    
    if(_cwmmQueryTrackStatus(somSelf)==TRACK_STATUS_STOPPED)
      return;

    switch(ulAction)
      {
      case ACKEY_PAUSE:

        /* Already paused? Shouldn't happen but I've seen it. */
        if(_cwmmQueryTrackStatus(somSelf)==TRACK_STATUS_PAUSED)
          return;

        /* Post a message to the object window handling the commands. */
        if(WinIsWindow(WinQueryAnchorBlock(HWND_DESKTOP),__get_hwndObjectPlay(somSelf)))
          WinPostMsg(__get_hwndObjectPlay(somSelf), WM_APPTERMINATENOTIFY, MPFROMLONG(ulAction), MPFROMP(somSelf));

        break;
      case ACKEY_RESUME:

        if(_cwmmQueryTrackStatus(somSelf)==TRACK_STATUS_PLAYING)
          return;

        if(WinIsWindow(WinQueryAnchorBlock(HWND_DESKTOP), __get_hwndObjectPlay(somSelf)))
          WinPostMsg(__get_hwndObjectPlay(somSelf), WM_APPTERMINATENOTIFY, MPFROMLONG(ulAction), MPFROMP(somSelf));
        break;
      default:
        break;
      }
}

#if 0
SOM_Scope long  SOMLINK cwaudio_cwmmSetTrackVolume(MMAudio *somSelf, 
                                                   ULONG ulVolume)
{
    MMAudioData *somThis = MMAudioGetData(somSelf);
    MMAudioMethodDebug("MMAudio","cwaudio_cwmmSetTrackVolume");

    /* Return statement to be customized: */
    return -1;
}

SOM_Scope long  SOMLINK cwaudio_cwmmQueryTrackVolume(MMAudio *somSelf)
{
    MMAudioData *somThis = MMAudioGetData(somSelf);
    MMAudioMethodDebug("MMAudio","cwaudio_cwmmQueryTrackVolume");

    /* Return statement to be customized: */
    return -1;
}
#endif

/****************************************************************/
/*
  Two new settings pages are added to every audio object:
  
  -Audio information showing playtime samplerate and so on.
  -Track information for editing artist name, album name and so
   on.
  
  */
/****************************************************************/
SOM_Scope BOOL  SOMLINK cwaudio_wpAddSettingsPages(MMAudio *somSelf, 
                                                   HWND hwndNotebook)
{
  BOOL rc;

  /*  MMAudioData *somThis = MMAudioGetData(somSelf);*/
    MMAudioMethodDebug("MMAudio","cwaudio_wpAddSettingsPages");


    rc= (MMAudio_parent_CWMMDataFile_wpAddSettingsPages(somSelf, hwndNotebook));

    /* Only insert trackname page if object isn't on CD. CDs don't support EAs so this page
       would be useless. */
    if(!cwObjectIsOnCD(somSelf))
      return rc | _cwmmAddAudioInformationPage(somSelf, hwndNotebook)|
        _cwmmAddTrackNamePage(somSelf, hwndNotebook);
    else
      return rc | _cwmmAddAudioInformationPage(somSelf, hwndNotebook);

}

/*
 * The prototype for cwaudio_wpQueryDetailsData was replaced by the following prototype:
 */
SOM_Scope ULONG  SOMLINK cwaudio_wpQueryDetailsData(MMAudio *somSelf, 
                                                    PVOID* ppDetailsData, 
                                                    PULONG pcp)
{
  BOOL rcParent;
  PAUDIODETAILS pAudioDetails;
    MMAudioData *somThis = MMAudioGetData(somSelf);
    MMAudioMethodDebug("MMAudio","cwaudio_wpQueryDetailsData");

    /* Call parent */
    rcParent= (MMAudio_parent_CWMMDataFile_wpQueryDetailsData(somSelf, 
                                                      ppDetailsData, 
                                                      pcp));

  /* The WPS asks for data to be displayed */
  if(ppDetailsData)
    {
      /* Fill the structure with the info to be displayed */      
      pAudioDetails=(PAUDIODETAILS)*ppDetailsData;  
      pAudioDetails->pszPlayTime=_chrPlayTime;
      pAudioDetails->pszBitRate=_chrBitRate;            /* New with 0.2.7 */
      pAudioDetails->pszSampleRate=_chrSampleRate;
      pAudioDetails->pszChannels=_chrChannels;
      pAudioDetails->pszBPS=_chrBPS;

      pAudioDetails->pszName=_pszName;
      pAudioDetails->pszArtist=_pszArtist;
      pAudioDetails->pszAlbum=_pszAlbum;
      pAudioDetails->pszYear=_pszYear;
      pAudioDetails->pszComment=_pszComment;
      pAudioDetails->pszGenre=_pszGenre;

#if 0
      pAudioDetails->pszName=_id3Name;
      pAudioDetails->pszArtist=_id3Artist;
      pAudioDetails->pszAlbum=_id3Album;
      pAudioDetails->pszYear=_id3Year;
      pAudioDetails->pszComment=_id3Comment;
      pAudioDetails->pszGenre=_id3Genre;
#endif
      *ppDetailsData=((PBYTE) (*ppDetailsData))+sizeof(*pAudioDetails);  
    }
  else
    {
      /* Buffer size is queried */
      if(pcp)
        *pcp+=sizeof(*pAudioDetails);
    }
    return rcParent;
}


/*
 * The prototype for cwaudio_wpRestoreState was replaced by the following prototype:
 */
SOM_Scope BOOL  SOMLINK cwaudio_wpRestoreState(MMAudio *somSelf, 
                                               ULONG ulReserved)
{
  BOOL bRc; 
  char fName[CCHMAXPATH];
  BOOL bReRead=FALSE;
  ULONG ulError;
  BOOL bIsMidi;
  PBYTE pByte;

   MMAudioData *somThis = MMAudioGetData(somSelf);
    MMAudioMethodDebug("MMAudio","cwaudio_wpRestoreState");

    bRc=(MMAudio_parent_CWMMDataFile_wpRestoreState(somSelf, ulReserved));

    _bNeedSaving=FALSE;

    /* Query the audio info */
    if(!_wpRestoreLong(somSelf, "CWAudio", KEY_FILESIZE, &_ulFileSize))
      bReRead=TRUE;
    if(!_wpRestoreLong(somSelf, "CWAudio", KEY_TIME, &_ulPlaySecs))
      bReRead=TRUE;
    if(!_wpRestoreLong(somSelf, "CWAudio", KEY_CHANNELS, &_ulChannels))
      bReRead=TRUE;
    if(!_wpRestoreLong(somSelf, "CWAudio", KEY_SAMPLERATE, &_ulSampleRate))
      bReRead=TRUE;
    if(!_wpRestoreLong(somSelf, "CWAudio", KEY_BPS, &_ulBPS))
      bReRead=TRUE;
    if(!_wpRestoreLong(somSelf, "CWAudio", KEY_TIME_MS, &_ulPlayMsecs))
      bReRead=TRUE;
    if(!_wpRestoreLong(somSelf, "CWAudio", KEY_NUM_AUDIO_BYTES, &_ulNumAudioBytes))
      bReRead=TRUE;

    /* New with 0.2.7 */
    if(EARestoreString(somSelf, "MMBITRATE", _chrBitRate, sizeof(_chrBitRate))) {
      _ulBitRate=atol(_chrBitRate);
    }
    else {
      //SysWriteToTrapLog("No EA for %s\n", _wpQueryTitle(somSelf));
      bReRead=TRUE;
    }
    /* Get audiotrack info from EA */
    if( (pByte=_wpAllocMem(somSelf, MAX_EA_SIZE, &ulError))!=NULLHANDLE)
      {
        _pszName=_readTrackInfoIntoMem(somSelf, "MMTRACKNAME" , pByte, MAX_EA_SIZE);
        _pszArtist=_readTrackInfoIntoMem(somSelf, "MMARTIST" , pByte, MAX_EA_SIZE);
        _pszAlbum=_readTrackInfoIntoMem(somSelf, "MMALBUM" , pByte, MAX_EA_SIZE);
        _pszYear=_readTrackInfoIntoMem(somSelf, "MMYEAR" , pByte, MAX_EA_SIZE);
        _pszComment=_readTrackInfoIntoMem(somSelf, "MMCOMMENT" , pByte, MAX_EA_SIZE);
        _pszGenre=_readTrackInfoIntoMem(somSelf, "MMGENRE" , pByte, MAX_EA_SIZE);
        _wpFreeMem(somSelf, pByte);
      }

#if 0
    cwGetStringFromEA(somSelf, "MMTRACKNAME" , _id3Name, sizeof(_id3Name));
    cwGetStringFromEA(somSelf, "MMARTIST" , _id3Artist, sizeof(_id3Artist));
    cwGetStringFromEA(somSelf, "MMALBUM" , _id3Album, sizeof(_id3Album));
    cwGetStringFromEA(somSelf, "MMYEAR" , _id3Year, sizeof(_id3Year));
    cwGetStringFromEA(somSelf, "MMCOMMENT" , _id3Comment, sizeof(_id3Comment));
    cwGetStringFromEA(somSelf, "MMGENRE" , _id3Genre, sizeof(_id3Genre));

    sprintf(chrBuffer,"%d",_ulSampleRate);
    cwSaveStringToEA(somSelf, "MMSAMPLERATE", chrBuffer);
    sprintf(chrBuffer,"%d",_ulChannels);
    cwSaveStringToEA(somSelf, "MMCHANNELS", chrBuffer);
    sprintf(chrBuffer,"%d",_ulBPS);
    cwSaveStringToEA(somSelf, "MMBPS", chrBuffer);
    sprintf(chrBuffer,"%d",_ulPlaySecs);
    cwSaveStringToEA(somSelf, "MMPLAYTIME", chrBuffer);
    sprintf(chrBuffer,"%d",_ulPlayMsecs);
    cwSaveStringToEA(somSelf, "MMPLAYTIMEMS", chrBuffer);
#endif

    if(_ulFileSize!=_wpQueryFileSize(somSelf))
      bReRead=TRUE; /* The filesize changed, somebody altered the audio file so reread the info */

    if(!_ulFileSize)
      bReRead=FALSE;
    /* If filesize=0 do nothing because the file was just created and there's no contents yet */
 
    //if(cwObjectIsOnCD(somSelf) && bReRead) {
    if(cwObjectIsOnInvalidDrive(somSelf)&& bReRead) {
      /* Only get audio info when file isn't on CD. This speeds up opening of folders on CDs filled with
         MP3s. Doesn't hurt because folders of CDs open in normal details view as default so the audio info
         isn't necessary. When opening the settings notebook the info is reread anyway. */      
      bReRead=FALSE;
    }
    bIsMidi=_somIsA(somSelf, somGetSomClass("MMMIDI"));
    if(bReRead){
      /* Some info changed or isn't present. Reread the audio information */

      /* Send the object pointer to the audio worker thread to read the audio info in the background.
         The audio worker thread was started during initialization of CWMMDataFile. 
         */
      if((bIsMidi && !globalHaveTimidity) || !bIsMidi)
        WinPostMsg(__get_hwndAudioWorker(_CWMMDataFile) , WM_APPTERMINATENOTIFY, somSelf, 0);

      /* Set default values into instance vars */
      if(bIsMidi)
        {
          /* MIDI files don't have this info. */
          strncpy(_chrSampleRate, "---", sizeof(_chrSampleRate));      
          strncpy(_chrBPS, "---", sizeof(_chrBPS));
        }
      else
        {
          strncpy(_chrSampleRate, "??", sizeof(_chrSampleRate));
          strncpy(_chrBPS, "??", sizeof(_chrBPS));
        }
      strncpy(_chrBitRate, "---", sizeof(_chrBitRate));
      strncpy(_chrChannels, "??", sizeof(_chrChannels));
      strncpy(_chrPlayTime, "??:??", sizeof(_chrPlayTime));

      _ulFileSize=0;
      _ulPlaySecs=0;
      _ulChannels=0;
      _ulSampleRate=0;
      _ulBitRate=0;
      _ulBPS=0;
      _ulPlayMsecs=0;
      _ulNumAudioBytes=0;
    }/* bReRead */
    else {
      /* No new reading necessary. Fill in the instance vars with the restored
         data. */
      sprintf(fName,"%d",_ulChannels);
      strncpy(_chrChannels, fName, sizeof(_chrChannels));
      
      if(bIsMidi)
        strncpy(_chrSampleRate, "---", sizeof(_chrSampleRate));      
      else {
        sprintf(fName,"%d", _ulSampleRate);
        strncpy(_chrSampleRate, fName, sizeof(_chrSampleRate));      
      }
      
      if(bIsMidi)
        strncpy(_chrBPS, "---", sizeof(_chrBPS));
      else {
        sprintf(fName,"%d",_ulBPS);
        strncpy(_chrBPS, fName, sizeof(_chrBPS));
      }
      /* Bitrate of MP3 files */
      if(!_ulBitRate)
        strncpy(_chrBitRate, "---", sizeof(_chrBitRate));
      else {
        sprintf(fName,"%d",_ulBitRate);
        strncpy(_chrBitRate, fName, sizeof(_chrBitRate));
      }

      sprintf(fName,"%02d:%02d",_ulPlaySecs/60, _ulPlaySecs%60);
      strncpy(_chrPlayTime, fName, sizeof(_chrPlayTime));
    }
    _chrChannels[sizeof(_chrChannels)-1]=0;
    _chrSampleRate[sizeof(_chrSampleRate)-1]=0;
    _chrBPS[sizeof(_chrBPS)-1]=0;
    _chrPlayTime[sizeof(_chrPlayTime)-1]=0;

    return bRc;
}

#if 0
static void _printObjectInfo(WPObject * wpObject)
{
  char chrFileName[CCHMAXPATH];
  ULONG       ulSize;
  PSZ pszID;

  ulSize=sizeof(chrFileName);
  _wpQueryRealName(wpObject, chrFileName,&ulSize,TRUE);
  SysWriteToTrapLog("Filename: %s \n", chrFileName);
  SysWriteToTrapLog("Object is initialized: %d (TRUE/FALSE)\n", _wpIsObjectInitialized(wpObject));
  SysWriteToTrapLog("Object style: %d 0x%x\n", _wpQueryStyle(wpObject), _wpQueryStyle(wpObject));
  if((pszID=_wpQueryObjectID(wpObject))!=NULLHANDLE)
    SysWriteToTrapLog("Object ID: %s\n\n", pszID);
  else
    SysWriteToTrapLog("Object ID: None\n\n");

}
#endif

/*
 * The prototype for cwaudio_wpSaveState was replaced by the following prototype:
 */
SOM_Scope BOOL  SOMLINK cwaudio_wpSaveState(MMAudio *somSelf)
{
  char chrBuffer[10];

    MMAudioData *somThis = MMAudioGetData(somSelf);
    MMAudioMethodDebug("MMAudio","cwaudio_wpSaveState");


    if(_ulFileSize) {
      _wpSaveLong(somSelf, "CWAudio", KEY_TIME,_ulPlaySecs);
      _wpSaveLong(somSelf, "CWAudio", KEY_SAMPLERATE,_ulSampleRate);
      _wpSaveLong(somSelf, "CWAudio", KEY_CHANNELS,_ulChannels);
      _wpSaveLong(somSelf, "CWAudio", KEY_BPS,_ulBPS);
      _wpSaveLong(somSelf, "CWAudio", KEY_FILESIZE,_ulFileSize);
      _wpSaveLong(somSelf, "CWAudio", KEY_TIME_MS,_ulPlayMsecs);
      _wpSaveLong(somSelf, "CWAudio", KEY_NUM_AUDIO_BYTES, _ulNumAudioBytes);
    }

#if 0
    _printObjectInfo(somSelf);
    cwSaveStringToEA(somSelf, "MMTRACKNAME", _pszName);
  if(_wpQueryStyle(somSelf)!=0x10000) {
    SysWriteToTrapLog("2 Template? %d \n", _wpQueryStyle(somSelf));
#endif

    /* Save audio info in EA for other programs */
    cwSaveStringToEA(somSelf, "MMTRACKNAME", _pszName);
    cwSaveStringToEA(somSelf, "MMARTIST", _pszArtist);
    cwSaveStringToEA(somSelf, "MMALBUM", _pszAlbum);
    cwSaveStringToEA(somSelf, "MMCOMMENT", _pszComment);
    cwSaveStringToEA(somSelf, "MMYEAR", _pszYear);
    cwSaveStringToEA(somSelf, "MMGENRE", _pszGenre);


#if 0
    cwSaveStringToEA(somSelf, "MMTRACKNAME", _id3Name);
    cwSaveStringToEA(somSelf, "MMARTIST", _id3Artist);
    cwSaveStringToEA(somSelf, "MMALBUM", _id3Album);
    cwSaveStringToEA(somSelf, "MMCOMMENT", _id3Comment);
    cwSaveStringToEA(somSelf, "MMYEAR", _id3Year);
    cwSaveStringToEA(somSelf, "MMGENRE", _id3Genre);
#endif

    sprintf(chrBuffer,"%d",_ulSampleRate);
    cwSaveStringToEA(somSelf, "MMSAMPLERATE", chrBuffer);
    sprintf(chrBuffer,"%d",_ulChannels);
    cwSaveStringToEA(somSelf, "MMCHANNELS", chrBuffer);
    sprintf(chrBuffer,"%d",_ulBPS);
    cwSaveStringToEA(somSelf, "MMBPS", chrBuffer);
    sprintf(chrBuffer,"%d",_ulPlaySecs);
    cwSaveStringToEA(somSelf, "MMPLAYTIME", chrBuffer);
    sprintf(chrBuffer,"%d",_ulPlayMsecs);
    cwSaveStringToEA(somSelf, "MMPLAYTIMEMS", chrBuffer);
    sprintf(chrBuffer,"%d",_ulNumAudioBytes);
    cwSaveStringToEA(somSelf, "MMNUMAUDIOBYTES", chrBuffer);

    /* New with 0.2.7 */
    sprintf(chrBuffer,"%d",_ulBitRate);
    EASaveString(somSelf, "MMBITRATE", chrBuffer);
#if 0
  }
#endif

#if 0
    cwGetStringFromEA(somSelf, "MMTRACKNAME" , chrBuf, sizeof(chrBuf));
    HlpWriteToTrapLog("Value: %s\n", chrBuf);
    cwGetStringFromEA(somSelf, "MMARTIST" , chrBuffer, sizeof(chrBuffer));
    cwGetStringFromEA(somSelf, "MMALBUM" , chrBuffer, sizeof(chrBuffer));
#endif

#if 0
    /* Set .TYPE EA so the editor and the player are happy. */
    strncpy(chrBuf, _wpQueryType(somSelf), sizeof(chrBuf));
    chrBuf[sizeof(chrBuf)-1]=0;

    if(!strstr(chrBuf, TYPE_DIGITALAUDIO)) {
      ulLength=strlen(chrBuf);
      if(ulLength) {
        if(ulLength+2+sizeof(TYPE_DIGITALAUDIO) < sizeof(chrBuf)) {
          strcat(chrBuf, "\n");
          strcat(chrBuf, TYPE_DIGITALAUDIO);
        }
      }
      else
        strcpy(chrBuf, TYPE_DIGITALAUDIO);      
      /* Set .TYPE EA so the editor and the player are happy. */
      _wpSetType(somSelf, chrBuf , NULL);
    }
#endif
    //_wpSetType(somSelf, "Digital Audio" , NULL);
    return (MMAudio_parent_CWMMDataFile_wpSaveState(somSelf));
}

/*
  FIXME:

  This function isn't thread safe because of one global memory area. It is supposed to be
  called from the wpPopupMenu() method. This method can only be called once at
  a time, so that's not a problem. It may become a problem if this function is also
  called from somewhere else. The global mem pointer is used by the image class and the
  audio class.

  This function inserts only write enabled IO procedures into the menu.
*/
static BOOL insertAudioIOProcMenuItems( HWND hwndMenu )
{
    CHAR          szBuffer[ sizeof( FOURCC ) + CCHMAXPATH + 4 ];
    MMFORMATINFO  mmFormatInfo;
    PMMFORMATINFO pmmFormatInfoArray;
    ULONG         ulReturnCode;
    LONG          lFormatsRead;
    LONG          index;
    LONG          lBytesRead;
    HWND hwndSubMenu;
    MENUITEM mi;
    LONG          lNumIOProcs;

    if(g_pmmFormatInfoArray)
      free(g_pmmFormatInfoArray);
    g_pmmFormatInfoArray=NULLHANDLE;

    memset( &mmFormatInfo,
            '\0',
            sizeof(MMFORMATINFO) );
    
    mmFormatInfo.ulMediaType |= MMIO_MEDIATYPE_AUDIO;
    mmFormatInfo.ulFlags|=MMIO_CANWRITETRANSLATED;/* FIXME: CANWRITEUNTRANSLATED???*/
    ulReturnCode = mmioQueryFormatCount ( &mmFormatInfo,
                                          &lNumIOProcs,
                                          0,
                                          0 );
    
    if( ulReturnCode != MMIO_SUCCESS )
      {
        /* Error - mmioQueryFormatCount failed. */
        return FALSE;
      }

    /*
     * Allocate enough memory for n number of FormatInfo blocks
     */
    g_pmmFormatInfoArray = malloc (lNumIOProcs * sizeof( MMFORMATINFO ) );
    if( g_pmmFormatInfoArray == NULL )
      {
        /* Could not allocate enough memory for mmFormatInfo array. */
        return FALSE;
      }
    
    /*
     * call mmioGetFormats to get info on the formats supported.
     */
    ulReturnCode = mmioGetFormats( &mmFormatInfo,
                                   lNumIOProcs,
                                   g_pmmFormatInfoArray,
                                   &lFormatsRead,
                                   0,
                                   0 );
    if( ulReturnCode != MMIO_SUCCESS )
      {
        /*
         *  mmioGetFormats failed.
         */
        free(g_pmmFormatInfoArray);
        g_pmmFormatInfoArray=NULLHANDLE;
        return FALSE;
      }
    
    if( lFormatsRead != lNumIOProcs )
      {
        /*
         * Error in MMIO - number of formats read in by
         * mmioGetFormats is not equal to number of formats
         * found by mmioQueryFormatCount.
         */
        free(g_pmmFormatInfoArray);
        g_pmmFormatInfoArray=NULLHANDLE;
        return FALSE;
      }

    // Create Empty Submenu //
    hwndSubMenu=WinCreateWindow(hwndMenu,WC_MENU,"",0,
                                0,0,0,0,
                                hwndMenu,//Owner. If set, this window 
                                //is destroyed if owner is destroyed
                                HWND_TOP,
                                ID_MENU_CONVERT,//menuid
                                NULL,NULL);

    mi.iPosition=MIT_END;
    mi.afStyle=MIS_TEXT;//|MIS_SUBMENU;
    mi.id=ID_MENU_CONVERT;
    mi.afAttribute=NULLHANDLE;    
    mi.hwndSubMenu=NULLHANDLE;//hwndSubMenu;
    mi.hItem=NULLHANDLE;
    mi.hwndSubMenu=hwndSubMenu;

    if(!getMessage(szBuffer, IDSTR_MENU_CONVERT, sizeof(szBuffer), queryResModuleHandle(), HWND_DESKTOP))
       sprintf(szBuffer,"~Convert to");
    WinSendMsg(hwndMenu,MM_INSERTITEM,(MPARAM)&mi,
               (MPARAM)szBuffer);

    pmmFormatInfoArray=g_pmmFormatInfoArray;
    for ( index = 0; index <lNumIOProcs; index++ )
      {
        mmioGetFormatName(pmmFormatInfoArray, szBuffer, &lBytesRead, 0L, 0L);
        
        /* Insert NULL string terminator */
        *( szBuffer + lBytesRead ) = (CHAR)NULL;

        /* Only write enabled IO procs are used in the convert menu.
         */
        if(pmmFormatInfoArray->ulFlags & MMIO_CANWRITETRANSLATED)
          {
            //  HlpWriteToTrapLog("IO-Proc 2: %s\n\n", szBuffer);
            /* Add menu item */
            /* Fill the MENUITEM structure */
            mi.iPosition=MIT_END;
            mi.afStyle=MIS_TEXT|MIS_SUBMENU;
            mi.id=ID_ITEM_FIRSTCONVERT+index;/* Create menu id */
            mi.afAttribute=NULLHANDLE;    
            mi.hwndSubMenu=NULLHANDLE;//hwndSubMenu;
            mi.hItem=NULLHANDLE;
            WinSendMsg(hwndSubMenu, MM_INSERTITEM,(MPARAM)&mi,
                       (MPARAM)szBuffer);
          }
        /*
         *  advance to next entry in mmFormatInfo array
         */
        pmmFormatInfoArray++;
      }
    return TRUE;
}


/*
 * The prototype for cwaudio_wpModifyPopupMenu was replaced by the following prototype:
 */
SOM_Scope BOOL  SOMLINK cwaudio_wpModifyPopupMenu(MMAudio *somSelf, 
                                                  HWND hwndMenu, 
                                                  HWND hwndCnr, 
                                                  ULONG iPosition)
{
  BOOL rc;

  MMAudioMethodDebug("MMAudio","cwaudio_wpModifyPopupMenu");

    /* New Volume item */
    _wpInsertPopupMenuItems(somSelf, hwndMenu, 1, queryResModuleHandle(), ID_MENU_VOLUME, 1);
    /* Convert menu item */

    /* Insert all known audio I/O procs */
    TRY_LOUD(AUDIO_INSERTPOPUPMENU) {
      insertAudioIOProcMenuItems( hwndMenu );
    }/* TRY_LOUD */
    CATCH(AUDIO_INSERTPOPUPMENU)
      {
        SysWriteToTrapLog("\nTrap occured in %s, file %s, near line %d.\n",
                          __FUNCTION__, __FILE__, __LINE__);
      } END_CATCH;

      if(WinIsWindow(WinQueryAnchorBlock(HWND_DESKTOP),__get_hwndObjectPlay(somSelf))) {
        if(_cwmmQueryTrackStatus(somSelf)==TRACK_STATUS_PAUSED)
          _wpInsertPopupMenuItems(somSelf, hwndMenu, 1, queryResModuleHandle(), ID_MENU_RESUME, 1);
        else
          _wpInsertPopupMenuItems(somSelf, hwndMenu, 1, queryResModuleHandle(), ID_MENU_PAUSE, 1);
        _wpInsertPopupMenuItems(somSelf, hwndMenu, 1, queryResModuleHandle(), ID_MENU_STOP, 1);
      }
    else
      {
        _wpInsertPopupMenuItems(somSelf, hwndMenu, 1, queryResModuleHandle(), ID_MENU_EDITOR, 1);
        _wpInsertPopupMenuItems(somSelf, hwndMenu, 1, queryResModuleHandle(), ID_MENU_PLAYER, 1);
        _wpInsertPopupMenuItems(somSelf, hwndMenu, 1, queryResModuleHandle(), ID_MENU_START, 1);
      }
    rc= (MMAudio_parent_CWMMDataFile_wpModifyPopupMenu(somSelf, 
                                                       hwndMenu, 
                                                       hwndCnr, 
                                                       iPosition));
    return rc;
}


/*
 * The prototype for cwaudio_wpMenuItemSelected was replaced by the following prototype:
 */
SOM_Scope BOOL  SOMLINK cwaudio_wpMenuItemSelected(MMAudio *somSelf, 
                                                   HWND hwndFrame, 
                                                   ULONG ulMenuId)
{
  /*    MMAudioData *somThis = MMAudioGetData(somSelf);*/
    MMAudioMethodDebug("MMAudio","cwaudio_wpMenuItemSelected");


    if(ulMenuId>=ID_ITEM_FIRSTCONVERT && ulMenuId<=ID_ITEM_FIRSTCONVERT+lNumIOProcs-1)
      {
        char chrEditor[CCHMAXPATH]={0};
        char chrParams[2*CCHMAXPATH]="\"";
        char *chrPtr=chrParams;
        ULONG ulSize;
        ULONG ulRc;
        
        PrfQueryProfileString(HINI_USERPROFILE, "CWMM", "audioconverter", "", chrEditor,
                              sizeof(chrEditor));
        chrPtr++;
        ulSize=sizeof(chrParams);
        _wpQueryRealName(somSelf, chrPtr, &ulSize, TRUE);
        strcat(chrPtr,"\" \"");
        chrPtr=strrchr(chrPtr, 0);
        mmioGetFormatName(&g_pmmFormatInfoArray[ulMenuId-ID_ITEM_FIRSTCONVERT], chrPtr,(LONG*) &ulSize, 0L, 0L);
        *( chrPtr + ulSize ) = (CHAR)NULL;
        strcat(chrPtr,"\"");

        if((ulRc=launchPMProg("", chrEditor, chrParams, somSelf, ulMenuId-ID_ITEM_FIRSTCONVERT))==NULLHANDLE) {
          /* Error */
          return TRUE;
        }
        return TRUE;
      }

    switch(ulMenuId)
      {
      case ID_MENU_VOLUME:
      case ID_MENU_START:
      case ID_MENU_STOP:
      case ID_MENU_PAUSE:
      case ID_MENU_RESUME:
      case ID_MENU_PLAYER:
      case ID_MENU_EDITOR:
      case ID_ITEM_CONVERT:
        _wpViewObject(somSelf, WinWindowFromID(hwndFrame, FID_CLIENT), ulMenuId,0);
        return TRUE;
      default:
        break;
      }
    return (MMAudio_parent_CWMMDataFile_wpMenuItemSelected(somSelf, 
                                                      hwndFrame, 
                                                      ulMenuId));
}

/*
 * The prototype for cwaudio_wpObjectReady was replaced by the following prototype:
 */
SOM_Scope void  SOMLINK cwaudio_wpObjectReady(MMAudio *somSelf, 
                                              ULONG ulCode, WPObject* refObject)
{
 MMAudioData *somThis = MMAudioGetData(somSelf);
  MMAudioMethodDebug("MMAudio","cwaudio_wpObjectReady");

  MMAudio_parent_CWMMDataFile_wpObjectReady(somSelf, ulCode, refObject);

  /* Set the type of this object to keep the MM player happy. */
  mmclsSetObjectType(somSelf);

  if(_bNeedSaving)
    _wpSaveDeferred(somSelf);
}


/*
 * The prototype for cwaudio_wpSetup was replaced by the following prototype:
 */
SOM_Scope BOOL  SOMLINK cwaudio_wpSetup(MMAudio *somSelf, PSZ pszSetupString)
{
  char buffer[MAX_EA_SIZE];
  ULONG bufferSize;

  MMAudioData *somThis = MMAudioGetData(somSelf);
    MMAudioMethodDebug("MMAudio","cwaudio_wpSetup");

    /* Setting volume while playing */
    bufferSize=sizeof(buffer);
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_MMAUDIOVOLUME, buffer, &bufferSize))
      {
        LONG l;

        l=atol(buffer);
        if(l>100)
          l=100;
        if(l<0)
          l=0;

        globalClassVolume=l;
        /* Now tell the running file if any */
        WinSendMsg(globalHwndObjectPlay, WM_APPTERMINATENOTIFY, MPFROMLONG(ACKEY_VOLUME), MPFROMP(globalObjectPlay));
      }

    /* These are the old setup strings. They will be removed in the future */
    bufferSize=sizeof(buffer);
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_AUDIOTRACKNAME, buffer, &bufferSize))
      {
        _cwmmSetTrackInfo(somSelf, buffer, 0, IDINFO_NAME);
      }

    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_AUDIOARTIST, buffer, &bufferSize))
      {
        _cwmmSetTrackInfo(somSelf, buffer, 0, IDINFO_ARTIST);
      }

    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_AUDIOALBUM, buffer, &bufferSize))
      {
        _cwmmSetTrackInfo(somSelf, buffer, 0, IDINFO_ALBUM);
      }

    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_AUDIOCOMMENT, buffer, &bufferSize))
      {
        _cwmmSetTrackInfo(somSelf, buffer, 0, IDINFO_COMMENT);
      }

    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_AUDIOGENRE, buffer, &bufferSize))
      {
        _cwmmSetTrackInfo(somSelf, buffer, 0, IDINFO_GENRE);
      }

    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_AUDIOYEAR, buffer, &bufferSize))
      {
        _cwmmSetTrackInfo(somSelf, buffer, 0, IDINFO_YEAR);
      }

    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_AUDIOPLAYTIME, buffer, &bufferSize))
      {
        int iPlaytime=atoi(buffer);
        if(iPlaytime<0)
          iPlaytime=0;
        _cwmmSetTrackInfo(somSelf, buffer, iPlaytime, IDINFO_PLAYTIME);
      }

    /* Refresh */
    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_REFRESH, buffer,&bufferSize))
      {
        _ulFileSize=1; /* Set filesize to 1 this will force a reread */
        /* Make sure MMIOMP3 doesn't take the time from the EA */
        cwSaveStringToEA(somSelf, "MMPLAYTIME", "");
        cwSaveStringToEA(somSelf, "MMPLAYTIMEMS", "");
        
        /* The filesize changed, somebody altered the audio file so reread the info */
        // if(!cwObjectIsOnCD(somSelf)) {
        if(!cwObjectIsOnInvalidDrive(somSelf)) {
          /* Only get audio info when file isn't on CD. This speeds up opening of folders on CDs filled with
             MP3s. Doesn't hurt because folders of CDs open in normal details view as default so the audio info
             isn't necessary. When opening the settings notebook the info is reread anyway. */      
          
          /* Send the object pointer to the audio worker thread to read the audio info in the background. */
          WinPostMsg(__get_hwndAudioWorker(_CWMMDataFile) , WM_APPTERMINATENOTIFY, somSelf, 0);
        }
        _wpCnrRefreshDetails(somSelf);
      }

    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_COPYTAGTO, buffer, &bufferSize))
      {
        /* The caller requested to copy the tags from this audio file to another */
        PBYTE pByte;
        ULONG ul;

        /* Length of instance var string can't be longer than MAX_EA_SIZE. See cwmmSetTrackInfo() */
        if((pByte=_wpAllocMem(somSelf, MAX_EA_SIZE+100, &ul))!=NULLHANDLE)
          {
            sprintf(pByte,"%s=%s;",SETUP_AUDIOTRACKNAME, _pszName);
            HlpSendCommandToObject( buffer, pByte);
         
            sprintf(pByte,"%s=%s",SETUP_AUDIOARTIST, _pszArtist);
            HlpSendCommandToObject( buffer, pByte);

            sprintf(pByte,"%s=%s",SETUP_AUDIOALBUM, _pszAlbum);
            HlpSendCommandToObject( buffer, pByte);
            
            sprintf(pByte,"%s=%s",SETUP_AUDIOCOMMENT, _pszComment);
            HlpSendCommandToObject( buffer, pByte);
            
            sprintf(pByte,"%s=%s",SETUP_AUDIOYEAR, _pszYear);
            HlpSendCommandToObject( buffer, pByte);
            
            sprintf(pByte,"%s=%s",SETUP_AUDIOGENRE, _pszGenre);
            HlpSendCommandToObject( buffer, pByte);
          }
      }

#if 0
    /* Old code using a static array. To be removed in V.0.2.8 */
    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_COPYTAGTO, buffer, &bufferSize))
      {
        /* The caller requested to copy the tags from this audio file to another */
        char chrCommand[200];

        sprintf(chrCommand,"%s=%s;",SETUP_AUDIOTRACKNAME, _id3Name);
        HlpSendCommandToObject( buffer, chrCommand);

        sprintf(chrCommand,"%s=%s",SETUP_AUDIOARTIST, _id3Artist);
        HlpSendCommandToObject( buffer, chrCommand);

        sprintf(chrCommand,"%s=%s",SETUP_AUDIOALBUM, _id3Album);
        HlpSendCommandToObject( buffer, chrCommand);

        sprintf(chrCommand,"%s=%s",SETUP_AUDIOCOMMENT, _id3Comment);
        HlpSendCommandToObject( buffer, chrCommand);

        sprintf(chrCommand,"%s=%s",SETUP_AUDIOYEAR, _id3Year);
        HlpSendCommandToObject( buffer, chrCommand);

        sprintf(chrCommand,"%s=%s",SETUP_AUDIOGENRE, _id3Genre);
        HlpSendCommandToObject( buffer, chrCommand);
      }
#endif

    /* The new MM* setup strings. These have a better naming */
    bufferSize=sizeof(buffer);
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_MMAUDIOTRACKNAME, buffer, &bufferSize))
      _cwmmSetTrackInfo(somSelf, buffer, 0, IDINFO_NAME);
      
    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_MMAUDIOARTIST, buffer, &bufferSize))
      _cwmmSetTrackInfo(somSelf, buffer, 0, IDINFO_ARTIST);
    
    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_MMAUDIOALBUM, buffer, &bufferSize))
      _cwmmSetTrackInfo(somSelf, buffer, 0, IDINFO_ALBUM);
    
    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_MMAUDIOCOMMENT, buffer, &bufferSize))
      _cwmmSetTrackInfo(somSelf, buffer, 0, IDINFO_COMMENT);
      
    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_MMAUDIOGENRE, buffer, &bufferSize))
      _cwmmSetTrackInfo(somSelf, buffer, 0, IDINFO_GENRE);
      
    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_MMAUDIOYEAR, buffer, &bufferSize))
      _cwmmSetTrackInfo(somSelf, buffer, 0, IDINFO_YEAR);
    
    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_MMAUDIOPLAYTIME, buffer, &bufferSize))
      {
        int iPlaytime=atoi(buffer);
        if(iPlaytime<0)
          iPlaytime=0;
        _cwmmSetTrackInfo(somSelf, buffer, iPlaytime, IDINFO_PLAYTIME);
      }

    /* Refresh */
    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_MMREFRESH, buffer,&bufferSize))
      {
        _ulFileSize=1; /* Set filesize to 1 this will force a reread */
        /* Make sure MMIOMP3 doesn't take the time from the EA */
        cwSaveStringToEA(somSelf, "MMPLAYTIME", "");
        cwSaveStringToEA(somSelf, "MMPLAYTIMEMS", "");

        /* The filesize changed, somebody altered the audio file so reread the info */
        //  if(!cwObjectIsOnCD(somSelf)) {
        if(!cwObjectIsOnInvalidDrive(somSelf)) {
          /* Only get audio info when file isn't on CD. This speeds up opening of folders on CDs filled with
             MP3s. Doesn't hurt because folders of CDs open in normal details view as default so the audio info
             isn't necessary. When opening the settings notebook the info is reread anyway. */      

          /* Send the object pointer to the audio worker thread to read the audio info in the background. */
          WinPostMsg(__get_hwndAudioWorker(_CWMMDataFile) , WM_APPTERMINATENOTIFY, somSelf, 0);
        }
        _wpCnrRefreshDetails(somSelf);
      }

    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_MMCOPYTAGTO, buffer, &bufferSize))
      {
        /* The caller requested to copy the tags from this audio file to another */
        PBYTE pByte;
        ULONG ul;
        
        /* Length of instance var string can't be longer than MAX_EA_SIZE. See cwmmSetTrackInfo() */
        if((pByte=_wpAllocMem(somSelf, MAX_EA_SIZE+100, &ul))!=NULLHANDLE)
          {
            if(_pszName) { /* Prevent inserting of (null) into the EA. (null) will be inserted by sprintf() */
              sprintf(pByte,"%s=%s;",SETUP_MMAUDIOTRACKNAME, _pszName);
              HlpSendCommandToObject( buffer, pByte);
            }
            if(_pszArtist) { /* Prevent inserting of (null) into the EA. (null) will be inserted by sprintf() */
              sprintf(pByte,"%s=%s",SETUP_MMAUDIOARTIST, _pszArtist);
              HlpSendCommandToObject( buffer, pByte);
            }
            if(_pszAlbum) { /* Prevent inserting of (null) into the EA. (null) will be inserted by sprintf() */
              sprintf(pByte,"%s=%s",SETUP_MMAUDIOALBUM, _pszAlbum);
              HlpSendCommandToObject( buffer, pByte);
            }
            if(_pszComment) { /* Prevent inserting of (null) into the EA. (null) will be inserted by sprintf() */
              sprintf(pByte,"%s=%s",SETUP_MMAUDIOCOMMENT, _pszComment);
              HlpSendCommandToObject( buffer, pByte);
            }
            if(_pszYear) { /* Prevent inserting of (null) into the EA. (null) will be inserted by sprintf() */
              sprintf(pByte,"%s=%s",SETUP_MMAUDIOYEAR, _pszYear);
              HlpSendCommandToObject( buffer, pByte);
            }
            if(_pszGenre) { /* Prevent inserting of (null) into the EA. (null) will be inserted by sprintf() */
              sprintf(pByte,"%s=%s",SETUP_MMAUDIOGENRE, _pszGenre);
              HlpSendCommandToObject( buffer, pByte);
            }
          }
      }
    
#if 0
    /* Old code using a static array. To be removed in V0.2.8 */
    bufferSize=sizeof(buffer); 
    if(_wpScanSetupString(somSelf, pszSetupString, SETUP_MMCOPYTAGTO, buffer, &bufferSize))
      {
        /* The caller requested to copy the tags from this audio file to another */
        char chrCommand[200];

        sprintf(chrCommand,"%s=%s;",SETUP_MMAUDIOTRACKNAME, _id3Name);
        HlpSendCommandToObject( buffer, chrCommand);

        sprintf(chrCommand,"%s=%s",SETUP_MMAUDIOARTIST, _id3Artist);
        HlpSendCommandToObject( buffer, chrCommand);

        sprintf(chrCommand,"%s=%s",SETUP_MMAUDIOALBUM, _id3Album);
        HlpSendCommandToObject( buffer, chrCommand);

        sprintf(chrCommand,"%s=%s",SETUP_MMAUDIOCOMMENT, _id3Comment);
        HlpSendCommandToObject( buffer, chrCommand);

        sprintf(chrCommand,"%s=%s",SETUP_MMAUDIOYEAR, _id3Year);
        HlpSendCommandToObject( buffer, chrCommand);

        sprintf(chrCommand,"%s=%s",SETUP_MMAUDIOGENRE, _id3Genre);
        HlpSendCommandToObject( buffer, chrCommand);
      }
#endif

    return (MMAudio_parent_CWMMDataFile_wpSetup(somSelf, pszSetupString));
}


/*
 *  wpSetTitle              : override;
 *    wpQueryRealName         : override;
 *    wpQueryTitle            : override;
 *    wpRefresh               : override;
 */

SOM_Scope HWND  SOMLINK cwaudio_wpOpen(MMAudio *somSelf, HWND hwndCnr, 
                                       ULONG ulView, ULONG param)
{
  ULONG ulRc;

  /*    CWAudioData *somThis = CWAudioGetData(somSelf);*/
  /*  CWMMDataFileData *somThis = CWMMDataFileGetData(somSelf); */
    MMAudioMethodDebug("MMAudio","cwaudio_wpOpen");

    switch(ulView)
      {
      case ID_MENU_START:
        {
          if(iRunningAudioFiles<MAX_AUDIOFILE_STARTS) {
            /*
              @@CHANGE 0.2.8

              Workaround for WPS chrash with Timidity: Open 'ID_MENU_START' disabled.
             */
            if(globalHaveTimidity && somObjectIsA(somSelf, "MMMidi"))
              return NULLHANDLE,
            /* Another audio file running */
            iRunningAudioFiles++;

            __set_ulPreviousView(somSelf, _wpQueryDefaultView(somSelf));/* Save the view set by the user                  */
            _cwmmPlayTrack(somSelf, hwndCnr, TRUE);      /* Start playing                                  */
            _wpSetDefaultView(somSelf, ID_MENU_STOP);    /* Set new view so doubleclick stops the playing. */
          }
          return NULLHANDLE;
        }
      case ID_MENU_STOP:
        {
          _cwmmPlayTrack(somSelf, hwndCnr, FALSE);     /* Stop playing                                   */
          _wpSetDefaultView(somSelf, __get_ulPreviousView(somSelf)); /* Restore the user view                          */
          return NULLHANDLE;
        }
      case ID_MENU_PAUSE:
        {
          _cwmmPauseTrack(somSelf, hwndCnr, ACKEY_PAUSE);
          return NULLHANDLE;
        }
      case ID_MENU_RESUME:
        {
          _cwmmPauseTrack(somSelf, hwndCnr, ACKEY_RESUME);
          return NULLHANDLE;
        }
      case ID_MENU_PLAYER:
        /*case 0xbbe5:   Player */
        {
          char chrPlayer[CCHMAXPATH]={0};
          char chrParams[CCHMAXPATH+2]="\"";
          char chrTitle[50];
          char *chrPtr=chrParams;
          ULONG ulSize;

          /* Build path for the audio player app */
          sprintf(chrPlayer, "%s\\bin\\%s", chrInstallDir, "mmplayer.exe");

          /* The user may override the audio player using a setting in the ini. Default is using the
             provided one.
             */
          PrfQueryProfileString(HINI_USERPROFILE, "CWMM", "audioplayer", chrPlayer, chrPlayer,sizeof(chrPlayer));
          chrPtr++;
          ulSize=sizeof(chrParams)-2;
          _wpQueryRealName(somSelf, chrPtr, &ulSize, TRUE); /* Add filename */
          strcat(chrPtr,"\"");

          /* Get the Title for the window list */
          if(!getMessage(chrTitle, IDSTR_AUDPLAYERTITLE, sizeof(chrTitle), queryResModuleHandle(), HWND_DESKTOP))
            strcpy(chrTitle, "Player");

          if((ulRc=launchPMProg(chrTitle, chrPlayer, chrParams, somSelf, ulView))==NULLHANDLE) {
            break;
          }
          return NULLHANDLE;
        }
      case ID_MENU_VOLUME:
        {
          char chrVolume[CCHMAXPATH]={0};
          char chrTitle[100]={0};
          char chrParam[CCHMAXPATH]="\"";
          ULONG ulRc;

          sprintf(chrVolume, "%s\\bin\\classvol.exe", queryInstallDir());
          
          ulRc=sizeof(chrParam);
          _wpQueryRealName(somSelf,chrParam+1, &ulRc, TRUE);
          strcat(chrParam,"\"");
          /* Get the Title for the window list */
          if(!getMessage(chrTitle, IDSTR_VOLUMETITLE, sizeof(chrTitle), queryResModuleHandle(), HWND_DESKTOP))
            strcpy(chrTitle, "Volume");

          if((ulRc=launchPMProg(chrTitle, chrVolume, chrParam, somSelf, ID_MENU_VOLUME))==0)
           return NULLHANDLE;

#if 0
          HOBJECT hObject;
          if((hObject=WinQueryObject("<MMPM2_MMVOLUME>"))!=NULLHANDLE)
            WinOpenObject(hObject, OPEN_DEFAULT, TRUE);
#endif
          return NULLHANDLE;
        }
      case ID_MENU_EDITOR:
        /* case 0xbc0d:  Editor */ 
        {
          char chrPlayer[CCHMAXPATH]={0};
          char chrParams[CCHMAXPATH+10]="-e \"";
          char chrTitle[50];
          char *chrPtr=chrParams;
          ULONG ulSize;

          /*
            Check if the user specified another audio editor. 
            */
          if(!PrfQueryProfileString(HINI_USERPROFILE, "CWMM", "audioeditor", NULLHANDLE, chrPlayer,sizeof(chrPlayer)))
            /* No user setting. Use default ab.exe copied by the installation program to another location. IF this setting is missing
             try the app from the path. */
            PrfQueryProfileString(HINI_USERPROFILE, "CWMM", "ab", "ab.exe", chrPlayer,sizeof(chrPlayer));
            
          chrPtr+=4;
          ulSize=sizeof(chrParams)-2;
          _wpQueryRealName(somSelf, chrPtr, &ulSize, TRUE);
          strcat(chrPtr,"\"");

          if(!getMessage(chrTitle, IDSTR_AUDEDITORTITLE, sizeof(chrTitle), queryResModuleHandle(), HWND_DESKTOP))
            strcpy(chrTitle, "Editor");

          if((ulRc=launchPMProg( chrTitle, chrPlayer, chrParams, somSelf, ulView))==NULLHANDLE) {
            break;
          }

          return NULLHANDLE;
        }
#if 0
        /* 
           FIXME:
           Moved this to wpMenuItemSelected(). Should be moved back later.
           */
      case 0xb4dd: /* Convert */ 
        {
          char chrPlayer[CCHMAXPATH]={0};
          char chrParams[CCHMAXPATH+2]="\"";
          char *chrPtr=chrParams;
          ULONG ulSize;

          PrfQueryProfileString(HINI_USERPROFILE, "CWMM", "audioconverter", "", chrPlayer,sizeof(chrPlayer));
          chrPtr++;
          ulSize=sizeof(chrParams)-2;
          _wpQueryRealName(somSelf, chrPtr, &ulSize, TRUE);
          strcat(chrPtr,"\"");
          if((ulRc=launchPMProg("Spieler", chrPlayer, chrParams, somSelf, ulView))==NULLHANDLE) {
            break;
          }
          return NULLHANDLE;
        }
#endif
      default:
        break;
      }
    return (MMAudio_parent_CWMMDataFile_wpOpen(somSelf, hwndCnr, ulView, 
                                          param));
}


SOM_Scope void  SOMLINK cwaudio_wpInitData(MMAudio *somSelf)
{
    MMAudioData *somThis = MMAudioGetData(somSelf);
    MMAudioMethodDebug("MMAudio","cwaudio_wpInitData");

    MMAudio_parent_CWMMDataFile_wpInitData(somSelf);
    /* Flag to mark we haven't yet the audio size. The size will be read from the
       EAs (to circumvent the IO proc file scanning) or by checking the file using
       IO procs when the file was altered. */
    _ulFileSize=1;

    /* This proc handles the start/stop/resume commands for audio objects.
       Playing takes place on a separate thread with an object window and this proc used
       for communicating. */
    _cwmmSetObjWindowProc(somSelf, &playObjectProc);
}

/*
  This function checks all the installed audio IO procs if one of them can handle the
  audio file with the given extension. Only write enabled IO procs are accepted because
  we use this function to determine if we should create a template for the audio class. 
 */
static BOOL checkForWriteEnabledAudioIOProc(char * chrExt)
{
    CHAR          szBuffer[ sizeof( FOURCC ) + CCHMAXPATH + 4 ];
    MMFORMATINFO  mmFormatInfo;
    PMMFORMATINFO pmmFormatInfoArray;
    void * memPtr;
    ULONG         ulReturnCode;
    LONG          lFormatsRead;
    LONG          index;
    LONG          lBytesRead;
    LONG          lNumIOProcs;

    memset( &mmFormatInfo,
            '\0',
            sizeof(MMFORMATINFO) );
    
    mmFormatInfo.ulMediaType |= MMIO_MEDIATYPE_AUDIO;
    mmFormatInfo.ulFlags|=MMIO_CANWRITETRANSLATED;
    ulReturnCode = mmioQueryFormatCount ( &mmFormatInfo,
                                          &lNumIOProcs,
                                          0,
                                          0 );
    
    if( ulReturnCode != MMIO_SUCCESS )
      {
        /*
         * Error - mmioQueryFormatCount failed.
         */
        return FALSE;
      }

    /*
     * Allocate enough memory for n number of FormatInfo blocks
     */
    pmmFormatInfoArray = malloc (lNumIOProcs * sizeof( MMFORMATINFO ) );
    memPtr=pmmFormatInfoArray;
    if( pmmFormatInfoArray == NULL )
      {
        /*
         * Could not allocate enough memory for mmFormatInfo array.
         */
        return FALSE;
      }
    
    /*
     * call mmioGetFormats to get info on the formats supported.
     */
    ulReturnCode = mmioGetFormats( &mmFormatInfo,
                                   lNumIOProcs,
                                   pmmFormatInfoArray,
                                   &lFormatsRead,
                                   0,
                                   0 );
    if( ulReturnCode != MMIO_SUCCESS )
      {
        /*
         *  mmioGetFormats failed.
         */
        free(pmmFormatInfoArray);
        return FALSE;
      }
    
    if( lFormatsRead != lNumIOProcs )
      {
        /*
         * Error in MMIO - number of formats read in by
         * mmioGetFormats is not equal to number of formats
         * found by mmioQueryFormatCount.
         */
        free(pmmFormatInfoArray);
        return FALSE;
      }

    for ( index = 0; index <lNumIOProcs; index++ )
      {
        mmioGetFormatName(pmmFormatInfoArray, szBuffer, &lBytesRead, 0L, 0L);
        
        /* Insert NULL string terminator */
        *( szBuffer + lBytesRead ) = (CHAR)NULL;

        if(pmmFormatInfoArray->ulFlags & MMIO_CANWRITETRANSLATED)
          {
            //if(pmmFormatInfoArray->fccIOProc==mmioStringToFOURCC(chr, MMIO_TOUPPER))
            //HlpWriteToTrapLog("%s --- %x %x %s\n",szBuffer, pmmFormatInfoArray->fccIOProc, mmioStringToFOURCC(chrType, MMIO_TOUPPER),
            // pmmFormatInfoArray->szDefaultFormatExt);
              if(strstr(chrExt, pmmFormatInfoArray->szDefaultFormatExt)) {
                //   HlpWriteToTrapLog("******* Ext given: %s  IO-Proc: %s\n", chrExt, pmmFormatInfoArray->szDefaultFormatExt);
                free(memPtr);
                return TRUE;
              }
          }
        /*
         *  advance to next entry in mmFormatInfo array
         */
        pmmFormatInfoArray++;
      }
    free(memPtr);
    return FALSE;
}

/*
 *    wpCreateShadowObject    : override;
 */

SOM_Scope void  SOMLINK cwaudio_wpUnInitData(MMAudio *somSelf)
{
    MMAudioData *somThis = MMAudioGetData(somSelf);
    MMAudioMethodDebug("MMAudio","cwaudio_wpUnInitData");

    if(_pszName)
      _wpFreeMem(somSelf, _pszName);
        
    if(_pszArtist)
      _wpFreeMem(somSelf, _pszArtist);
    
    if(_pszAlbum)
      _wpFreeMem(somSelf, _pszAlbum);

    if(_pszComment)
      _wpFreeMem(somSelf, _pszComment);

    if(_pszYear)
      _wpFreeMem(somSelf, _pszYear);

    if(_pszGenre)
      _wpFreeMem(somSelf, _pszGenre);

    MMAudio_parent_CWMMDataFile_wpUnInitData(somSelf);
}


/*
  Only templates for write enabled audio IO procs are created in this method. 
 */
SOM_Scope BOOL  SOMLINK cwaudioM_wpclsCreateDefaultTemplates(M_MMAudio *somSelf, 
                                                             WPObject* Folder)
{
    M_MMAudioMethodDebug("M_MMAudio","cwaudioM_wpclsCreateDefaultTemplates");

    //HlpWriteToTrapLog("Classtitle: %s, Type: %s\n",_wpclsQueryTitle(somSelf), _wpclsQueryInstanceType(somSelf));
    if(checkForWriteEnabledAudioIOProc( _wpclsQueryInstanceFilter(somSelf))) {
      /* A write enabled IO proc was found, create the template. */
      mmclsCreateTheDefaultTemplate(somSelf, Folder);
      return TRUE; /* Tell the WPS template created*/
    }

    return TRUE; /* We created the template or don't want to have one */
}


SOM_Scope PSZ  SOMLINK cwaudioM_wpclsQueryInstanceType(M_MMAudio *somSelf)
{
    /* M_MMAudioData *somThis = M_MMAudioGetData(somSelf); */
    M_MMAudioMethodDebug("M_MMAudio","cwaudioM_wpclsQueryInstanceType");

    return TYPE_DIGITALAUDIO;
}

SOM_Scope PSZ  SOMLINK cwaudioM_wpclsQueryInstanceFilter(M_MMAudio *somSelf)
{
    /* M_MMAudioData *somThis = M_MMAudioGetData(somSelf); */
    M_MMAudioMethodDebug("M_MMAudio","cwaudioM_wpclsQueryInstanceFilter");

    /* The list of additional extensions is built in wpclsInitData(). 

       FIXME
       This is a static list read in only once during startup.
       Should probably be changed later on.
       */
    return chrMMAudioExt;
    /*   return (M_MMAudio_parent_M_CWMMDataFile_wpclsQueryInstanceFilter(somSelf)); */
}

/*
 * The prototype for cwaudioM_wpclsQueryDetailsInfo was replaced by the following prototype:
 */
SOM_Scope ULONG  SOMLINK cwaudioM_wpclsQueryDetailsInfo(M_MMAudio *somSelf, 
                                                        PCLASSFIELDINFO* ppClassFieldInfo, 
                                                        PULONG pSize)
{
  ULONG cParentColumns;
  PCLASSFIELDINFO pCfi;
  int i;

    /* M_CWAudioData *somThis = M_CWAudioGetData(somSelf); */
    M_MMAudioMethodDebug("M_MMAudio","cwaudioM_wpclsQueryDetailsInfo");

    cParentColumns= (M_MMAudio_parent_M_CWMMDataFile_wpclsQueryDetailsInfo(somSelf, 
                                                             ppClassFieldInfo, 
                                                             pSize));
  if(pSize)
    *pSize+=sizeof(AUDIODETAILS);

  if(ppClassFieldInfo)
    {
      if(*ppClassFieldInfo)
        {
          pCfi=*ppClassFieldInfo;
          for(i=0; i<cParentColumns;i++)
            pCfi=(pCfi->pNextFieldInfo ? pCfi->pNextFieldInfo: pCfi);

          pCfi->pNextFieldInfo=cfiFieldInfo;
        }
      else
        *ppClassFieldInfo=cfiFieldInfo;
    }
    return (cParentColumns+NUM_AUDIO_FIELDS);
}


/*
 * The prototype for cwaudioM_wpclsQueryTitle was replaced by the following prototype:
 */
SOM_Scope PSZ  SOMLINK cwaudioM_wpclsQueryTitle(M_MMAudio *somSelf)
{
  static char chrTitle[30]={0};
  
  M_MMAudioMethodDebug("M_MMAudio","cwaudioM_wpclsQueryTitle");
  
  if(chrTitle[0]==0)
    if(!getMessage(chrTitle, IDSTR_CWAUDIOTITLE, sizeof(chrTitle), queryResModuleHandle(), HWND_DESKTOP))
      strcpy(chrTitle, CLSTITLE_DIGITALAUDIO);
  
  return chrTitle;
}

/*
  Initialize the MMAudio class.
 */
SOM_Scope void  SOMLINK cwaudioM_wpclsInitData(M_MMAudio *somSelf)
{
  PCLASSFIELDINFO pCfi;
  USHORT i;
  static BOOL bGotAudioExt=FALSE;

  /*    M_CWAudioData *somThis = M_CWAudioGetData(somSelf); */
    M_MMAudioMethodDebug("M_MMAudio","cwaudioM_wpclsInitData");

    /* 
       Get extensions of additional audio procs. These extensions may be specified by
       newly installed IO procs in MMPM2.INI or by using the Multimedia setup. For
       example the MMIOMP3 procedure for reading MP3 files adds the MP3 extension this
       way to the system. Extensions already handled by a specialized class will be
       filtered in the called REXX script e.g. MP3 so only unknown extensions end up here.

       Strangely enough wpclsQueryInstanceFilter() is called during wpclsInitData() so
       we query the extensions here before calling the parent.

       FIXME:
       The check is only done once during initialization. This is a little annoyance for
       the user because new extension specified in the settings will only be picked up
       on next WPS start. 
       */
     if(!bGotAudioExt)
      {
        char chrTimidity[4];
        getStringFromRexxScript("audioext.rx", chrMMAudioExt, sizeof(chrMMAudioExt));
        bGotAudioExt=TRUE; 
        getStringFromRexxScript("chktimid.rx", chrTimidity, sizeof(chrTimidity));
        //      SysWriteToTrapLog("%s %d\n", chrTimidity, atol(chrTimidity));
        globalHaveTimidity=atol(chrTimidity);
      }

    M_MMAudio_parent_M_CWMMDataFile_wpclsInitData(somSelf);

    /* Get strings for details view titled from the ressource DLL */
    if(getMessage(chrPlayTime, IDSTR_PLAYTIME, sizeof(chrPlayTime),  queryResModuleHandle(), HWND_DESKTOP))
      pszAudioColTitles[0]=chrPlayTime;
    /* New with 0.2.7 */
    if(getMessage(chrSampleRate, IDSTR_BITRATE, sizeof(chrBitRate),  queryResModuleHandle(), HWND_DESKTOP))
      pszAudioColTitles[1]=chrBitRate;

    if(getMessage(chrSampleRate, IDSTR_SAMPLERATE, sizeof(chrSampleRate),  queryResModuleHandle(), HWND_DESKTOP))
      pszAudioColTitles[2]=chrSampleRate;
    if(getMessage(chrChannels, IDSTR_CHANNELS, sizeof(chrChannels),  queryResModuleHandle(), HWND_DESKTOP))
      pszAudioColTitles[3]=chrChannels;
    if(getMessage(chrBPS, IDSTR_BPS, sizeof(chrBPS),  queryResModuleHandle(), HWND_DESKTOP))
      pszAudioColTitles[4]=chrBPS;

    if(getMessage(chrName, IDSTR_TITLE, sizeof(chrName),  queryResModuleHandle(), HWND_DESKTOP))
      pszAudioColTitles[5]=chrName;
    if(getMessage(chrArtist, IDSTR_ARTIST, sizeof(chrArtist),  queryResModuleHandle(), HWND_DESKTOP))
      pszAudioColTitles[6]=chrArtist;
    if(getMessage(chrAlbum, IDSTR_ALBUM, sizeof(chrAlbum),  queryResModuleHandle(), HWND_DESKTOP))
      pszAudioColTitles[7]=chrAlbum;
    if(getMessage(chrYear, IDSTR_YEAR, sizeof(chrYear),  queryResModuleHandle(), HWND_DESKTOP))
      pszAudioColTitles[8]=chrYear;
    if(getMessage(chrComment, IDSTR_COMMENT, sizeof(chrComment),  queryResModuleHandle(), HWND_DESKTOP))
      pszAudioColTitles[9]=chrComment;
    if(getMessage(chrGenre, IDSTR_GENRE, sizeof(chrGenre),  queryResModuleHandle(), HWND_DESKTOP))
      pszAudioColTitles[10]=chrGenre;


  /* Setup the static data for the details view */
  for(i=0,pCfi=cfiFieldInfo;i<NUM_AUDIO_FIELDS;i++,pCfi++)
    {
      memset((PCH)pCfi,0,sizeof(CLASSFIELDINFO));

      pCfi->cb=sizeof(CLASSFIELDINFO);
      pCfi->flData=CFA_LEFT|CFA_SEPARATOR|CFA_FIREADONLY;
      pCfi->flTitle=CFA_CENTER|CFA_SEPARATOR|CFA_HORZSEPARATOR|CFA_STRING|CFA_FITITLEREADONLY;
      pCfi->pNextFieldInfo=pCfi+1;
      pCfi->pTitleData=(PVOID)pszAudioColTitles[i];
      pCfi->flCompare=COMPARE_SUPPORTED|SORTBY_SUPPORTED;

      switch(i)
        {
        case 0: /* play time */
          pCfi->flData|=CFA_STRING;
          pCfi->offFieldData=(ULONG)(FIELDOFFSETUL(AUDIODETAILS,pszPlayTime));
          pCfi->ulLenFieldData=sizeof(PSZ);
          pCfi->DefaultComparison=CMP_EQUAL;
          break;
        case 1: /* Bitrate */     /* New with 0.2.7 */
          pCfi->flData|=CFA_STRING;
          pCfi->offFieldData=(ULONG)(FIELDOFFSETUL(AUDIODETAILS,pszBitRate));
          pCfi->ulLenFieldData=sizeof(PSZ);
          pCfi->DefaultComparison=CMP_EQUAL;
          break;
        case 2: /* Sample rate */
          pCfi->flData|=CFA_STRING;
          pCfi->offFieldData=(ULONG)(FIELDOFFSETUL(AUDIODETAILS,pszSampleRate));
          pCfi->ulLenFieldData=sizeof(PSZ);
          pCfi->DefaultComparison=CMP_EQUAL;
          break;
        case 3: /* Channels */
          pCfi->flData|=CFA_STRING;
          pCfi->offFieldData=(ULONG)(FIELDOFFSETUL(AUDIODETAILS,pszChannels));
          pCfi->ulLenFieldData=sizeof(PSZ);
          pCfi->DefaultComparison=CMP_EQUAL;
          break;
        case 4: /* BPS */
          pCfi->flData|=CFA_STRING;
          pCfi->offFieldData=(ULONG)(FIELDOFFSETUL(AUDIODETAILS,pszBPS));
          pCfi->ulLenFieldData=sizeof(PSZ);
          pCfi->DefaultComparison=CMP_EQUAL;
          break;

        case 5: 
          pCfi->flData|=CFA_STRING;
          pCfi->offFieldData=(ULONG)(FIELDOFFSETUL(AUDIODETAILS,pszName));
          pCfi->ulLenFieldData=sizeof(PSZ);
          pCfi->DefaultComparison=CMP_EQUAL;
          break;
        case 6: 
          pCfi->flData|=CFA_STRING;
          pCfi->flData|=CFA_STRING;
          pCfi->offFieldData=(ULONG)(FIELDOFFSETUL(AUDIODETAILS,pszArtist));
          pCfi->ulLenFieldData=sizeof(PSZ);
          pCfi->DefaultComparison=CMP_EQUAL;
          break;
        case 7: 
          pCfi->flData|=CFA_STRING;
          pCfi->offFieldData=(ULONG)(FIELDOFFSETUL(AUDIODETAILS,pszAlbum));
          pCfi->ulLenFieldData=sizeof(PSZ);
          pCfi->DefaultComparison=CMP_EQUAL;
          break;
        case 8: 
          pCfi->flData|=CFA_STRING;
          pCfi->offFieldData=(ULONG)(FIELDOFFSETUL(AUDIODETAILS,pszYear));
          pCfi->ulLenFieldData=sizeof(PSZ);
          pCfi->DefaultComparison=CMP_EQUAL;
          break;
        case 9: 
          pCfi->flData|=CFA_STRING;
          pCfi->offFieldData=(ULONG)(FIELDOFFSETUL(AUDIODETAILS,pszComment));
          pCfi->ulLenFieldData=sizeof(PSZ);
          pCfi->DefaultComparison=CMP_EQUAL;
          break;
        case 10: 
          pCfi->flData|=CFA_STRING;
          pCfi->offFieldData=(ULONG)(FIELDOFFSETUL(AUDIODETAILS,pszGenre));
          pCfi->ulLenFieldData=sizeof(PSZ);
          pCfi->DefaultComparison=CMP_EQUAL;
          break;

        }/* switch(i) */
    }/* for() */
  cfiFieldInfo[NUM_AUDIO_FIELDS].pNextFieldInfo=NULL;

  /* Get name of help library from resource */
  if(!getMessage(chrHelpLibrary, IDSTR_HELPLIBRARY, sizeof(chrHelpLibrary),
                 queryResModuleHandle(), HWND_DESKTOP))
        strcpy(chrHelpLibrary,"MMPARTS.HLP"); /* Fall back to default Warp hel library */
}




SOM_Scope void  SOMLINK cwaudioM_wpclsUnInitData(M_MMAudio *somSelf)
{
    /* M_MMAudioData *somThis = M_MMAudioGetData(somSelf); */
    M_MMAudioMethodDebug("M_MMAudio","cwaudioM_wpclsUnInitData");

    M_MMAudio_parent_M_CWMMDataFile_wpclsUnInitData(somSelf);
}

/*
 * The prototype for cwaudioM_wpclsQueryDefaultView was replaced by the following prototype:
 */
SOM_Scope ULONG  SOMLINK cwaudioM_wpclsQueryDefaultView(M_MMAudio *somSelf)
{
    /* M_CWAudioData *somThis = M_CWAudioGetData(somSelf); */
    M_MMAudioMethodDebug("M_MMAudio","cwaudioM_wpclsQueryDefaultView");

    /* Default view for audio objects is 'Start' so on doubleclick the playing starts
       immediately. */
    /*
      @@CHANGE 0.2.8

      Set default view for midi files to player when Timidity is installed. 'Start'
      menu isn't available then (see cwmidi.c).
     */
    if(globalHaveTimidity && somObjectIsA(somSelf, "M_MMMidi"))
      return ID_MENU_PLAYER;

    return ID_MENU_START;
    //    return (M_CWAudio_parent_M_MMAudio_wpclsQueryDefaultView(somSelf));
}

/*
 * The prototype for cwaudioM_wpclsQueryIconData was replaced by the following prototype:
 */
SOM_Scope ULONG  SOMLINK cwaudioM_wpclsQueryIconData(M_MMAudio *somSelf, 
                                                     PICONINFO pIconInfo)
{
  HMODULE hmod;
    /* M_CWAudioData *somThis = M_CWAudioGetData(somSelf); */
    M_MMAudioMethodDebug("M_MMAudio","cwaudioM_wpclsQueryIconData");
    /*
      We have our own icon.
      */
    hmod=queryModuleHandle();
    if(!hmod)
      return M_MMAudio_parent_M_CWMMDataFile_wpclsQueryIconData(somSelf, pIconInfo);

	if (pIconInfo)   {
      pIconInfo->fFormat = ICON_RESOURCE;
      pIconInfo->hmod    = queryModuleHandle();
      pIconInfo->resid   = ID_ICONCWAUDIOFILE;
	} /* endif */

	return ( sizeof(ICONINFO) );
}



MRESULT EXPENTRY audioWorkerProc(HWND hwnd, ULONG msg, MPARAM mp1, MPARAM mp2)
{

  switch (msg)
    {
    case WM_APPTERMINATENOTIFY:
      {
      ULONG ulSize;
      char fName[CCHMAXPATH];
      char text[CCHMAXPATH];
      BOOL bContinue=FALSE;
      MMAudio *somSelf=(MMAudio*)mp1;
      WPObject    *pLinkObj=NULLHANDLE;
      MMAudioData *somThis= MMAudioGetData(somSelf);
      ULONG ulLoop;

      TRY_LOUD(AUDIO_WORKER) {
        for(;;) {
          ULONG rc;
          MMIOINFO mmio;
          HMMIO hmmio;
          MMAUDIOHEADER mmAudioHeader={0};
          LONG lBytesRead=0;
          char* pChar;
          ULONG ulFSize;
          BOOL bIsMidi=FALSE;
          WPFolder *wpFolder;

          mmclsSetObjectType(somSelf);

          if(!somIsObj(somSelf))
            break;

          /* Don't check stream objects */
          if(somObjectIsA(somSelf, "MMAudioStream"))
            break;
          /* Don't check CD-Track objects */
          if(somObjectIsA(somSelf, "MMCDTrack"))
            break;

          /* Check if object is inserted into a container. If not the folder was
             closed. */
          // if(!somObjectIsInsertedInContainer(somSelf))
          //  break;

          ulFSize=_wpQueryFileSize(somSelf);
          if(_ulFileSize==ulFSize)
            break;    /* We already scanned this file */

          /*
            @@CHANGE 0.2.8

            Check if parent folder is closed. If yes, don't start file scanning.

            @@CHANGE 0.2.9

            Check if we have a shadow in an open folder.

            */

          wpFolder=_wpQueryFolder(somSelf);
          if(somIsObj(wpFolder)) {
            if(!_wpFindViewItem(wpFolder , VIEW_ANY, NULLHANDLE)) {
              PUSEITEM pUseItem;
              BOOL fOpenView=FALSE;
              /* Ok, our object isn't in an open folder, but we may have a shadow somewhere in an
                 open folder. */
              for(pUseItem=_wpFindUseItem(somSelf, USAGE_LINK, NULL);pUseItem;
                  pUseItem=_wpFindUseItem(somSelf, USAGE_LINK, pUseItem))
                {
                  PLINKITEM pLI=(PLINKITEM)++pUseItem;
                  pLinkObj=pLI->LinkObj; /* The awake shadow */

                  if(somIsObj(pLinkObj)) {
                    wpFolder=_wpQueryFolder(pLinkObj);
                    if(somIsObj(wpFolder)) {
                      if(_wpFindViewItem(wpFolder , VIEW_ANY, NULLHANDLE)) {
                        fOpenView=TRUE;
                        break;
                      }
                    }/* somIsObj(wpFolder) */
                  }
                }/* for() */
              if(!fOpenView)
                break;
            }
          }

          /* Get file name */
          ulSize=sizeof(fName);
          if(!_wpQueryRealName(somSelf, fName, &ulSize, TRUE))
            break; /* Error */

          /* Show status window */
          if((pChar=strrchr(fName, '\\'))!=NULLHANDLE) {
            HPS hps;
            ULONG ulWinTextLen;
            POINTL aptlPoints[TXTBOX_COUNT];
            SWP swp;
            ULONG ulCy;
            WPOINT pwpBorder;

            HWND hwndClient=WinWindowFromID(__get_hwndStatus(_CWMMDataFile), FID_CLIENT);

            sprintf(text,"%c:\\...%s",fName[0], pChar);
          
            WinSetWindowText(hwndClient, text);
            ulWinTextLen=(ULONG)strlen(text); // Query text length

            /* Calculate text size in pixel */
            hps=WinBeginPaint(hwndClient,(HPS)NULL,(PRECTL)NULL);
            GpiQueryTextBox(hps,ulWinTextLen,text,TXTBOX_COUNT,aptlPoints);
            WinEndPaint(hps);

            if(WinSendMsg(__get_hwndStatus(_CWMMDataFile) ,WM_QUERYBORDERSIZE, MPFROMP(&pwpBorder), 0L))
              ulCy=pwpBorder.x*2;
            else
              ulCy=SV_CYBORDER*2; /* Safe default */

            if(WinQueryWindowPos(WinWindowFromID(__get_hwndStatus(_CWMMDataFile), FID_TITLEBAR),&swp))
              {
                if(!swp.cy)
                  if(!WinQueryWindowPos(WinWindowFromID(HWND_DESKTOP, FID_TITLEBAR), &swp))
                    swp.cy=15;
                ulCy+=swp.cy;
              }
            else
              ulCy+=15;

            WinSetWindowPos(__get_hwndStatus(_CWMMDataFile), HWND_TOP, 0,0,
                            aptlPoints[TXTBOX_BOTTOMRIGHT].x-aptlPoints[TXTBOX_BOTTOMLEFT].x+18,
                            aptlPoints[TXTBOX_TOPRIGHT].y-aptlPoints[TXTBOX_BOTTOMRIGHT].y+ulCy+4,
                            SWP_SIZE|SWP_SHOW|SWP_ZORDER|SWP_DEACTIVATE);
            WinPostMsg(__get_hwndStatus(_CWMMDataFile), WM_APPTERMINATENOTIFY, 0,MPFROMLONG(1L));
          }

          //#if 0
          /* This part obsolete?? */
          /* Get file name */
          ulSize=sizeof(fName);
          if(!_wpQueryRealName(somSelf, fName, &ulSize, TRUE))
            break;
          //#endif

          if(!_somIsA(somSelf, somGetSomClass("MMMIDI")))
            {
              /* Check audio files */
              MP3OPTIONS mp3Opt={0}; /* Struct holding MP3 additional info */
              VORBISOPTIONS vorbisOpt={0};
      
              PMP3OPTIONS returnedMP3Opts;
              PVORBISOPTIONS returnedVorbisOpts;

              memset(&mmio,0, sizeof(mmio));
              mmio.ulFlags=MMIO_READ;
              mmio.ulTranslate=MMIO_TRANSLATEHEADER;

              hmmio = mmioOpen(fName, &mmio, MMIO_READ);
              if(!hmmio)
                break;

              /* The Quicktime IO-procs don't like any data in mmio.pExtraInfoStruct when calling
                 mmioOpen(). But we need that if we want to have the bitrate of MP3 and Ogg. So the
                 file is closed here and opened again with the FourCC set to MP3 or OGGS. So the Quicktime
                 IO-procs will not be called.*/
              if(somObjectIsA(somSelf, "MMOGG"))
                {
                  if(mmioFOURCC('O', 'G', 'G', 'S')==mmio.fccIOProc) { 
                    mmioClose(hmmio, 0);
                    
                    memset(&mmio,0, sizeof(mmio));
                    mmio.ulFlags=MMIO_READ;
                    mmio.ulTranslate=MMIO_TRANSLATEHEADER;
                    mmio.fccIOProc=mmioFOURCC('O', 'G', 'G', 'S');
                    vorbisOpt.cookie = VORBIS_COOKIE;
                    mmio.pExtraInfoStruct = &vorbisOpt;
                    /*Now reopen */
                    hmmio = mmioOpen(fName, &mmio, MMIO_READ);
                    if(!hmmio)
                      break;
                  }
                }
              else if(somObjectIsA(somSelf, "MMMP3"))
                {
                  if(mmioFOURCC('M', 'P', '3', ' ')==mmio.fccIOProc) { 
                    mmioClose(hmmio, 0);
                    
                    memset(&mmio,0, sizeof(mmio));
                    mmio.ulFlags=MMIO_READ;
                    mmio.ulTranslate=MMIO_TRANSLATEHEADER;
                    mmio.fccIOProc=mmioFOURCC('M', 'P', '3', ' ');
                    /* For bitrate query of MP3 */
                    mp3Opt.cookie = MP3_COOKIE;
                    mmio.pExtraInfoStruct = &mp3Opt;              
                    /*Now reopen */
                    hmmio = mmioOpen(fName, &mmio, MMIO_READ);
                    if(!hmmio)
                      break;

                    //SysWriteToTrapLog("%s reopened. mp3Opt.bitrate: %d\n", fName, mp3Opt.bitrate);
                  }
                }
              
              memset(&mmAudioHeader,0,sizeof(MMAUDIOHEADER));
              rc = mmioGetHeader(hmmio, &mmAudioHeader,sizeof(MMAUDIOHEADER),
                                 &lBytesRead, 0, 0);
              
              if(rc!=MMIO_SUCCESS) {
                mmioClose(hmmio, 0);
                break;
              }

              mmioClose(hmmio, 0);

              /* Check if the object is still living. */
              if(!somIsObj(somSelf))
                break;

              _ulBitRate=0;
              if(somObjectIsA(somSelf, "MMOGG")) {
                returnedVorbisOpts = (PVORBISOPTIONS)mmAudioHeader.mmXWAVHeader.XWAVHeaderInfo.pAdditionalInformation;
                if(0 != returnedVorbisOpts && VORBIS_COOKIE == returnedVorbisOpts->cookie && 0 != returnedVorbisOpts->nominal_bitrate)
                  _ulBitRate=returnedVorbisOpts->nominal_bitrate;
              }
              else if(somObjectIsA(somSelf, "MMMP3")) {
                returnedMP3Opts = (PMP3OPTIONS)mmAudioHeader.mmXWAVHeader.XWAVHeaderInfo.pAdditionalInformation;
                if(0 != returnedMP3Opts && MP3_COOKIE == returnedMP3Opts->cookie && 0 != returnedMP3Opts->bitrate)
                  _ulBitRate=returnedMP3Opts->bitrate;
              }

              _ulChannels=mmAudioHeader.mmXWAVHeader.WAVEHeader.usChannels;
              _ulSampleRate=mmAudioHeader.mmXWAVHeader.WAVEHeader.ulSamplesPerSec;
              _ulBPS=mmAudioHeader.mmXWAVHeader.WAVEHeader.usBitsPerSample;
              _ulNumAudioBytes=mmAudioHeader.mmXWAVHeader.XWAVHeaderInfo.ulAudioLengthInBytes;
              /*      sprintf(fName,"%02d:%02d",mmAudioHeader.mmXWAVHeader.XWAVHeaderInfo.ulAudioLengthInBytes/
                      mmAudioHeader.mmXWAVHeader.WAVEHeader.ulAvgBytesPerSec/60,
                      mmAudioHeader.mmXWAVHeader.XWAVHeaderInfo.ulAudioLengthInBytes/
                      mmAudioHeader.mmXWAVHeader.WAVEHeader.ulAvgBytesPerSec%60);*/
              if(mmAudioHeader.mmXWAVHeader.XWAVHeaderInfo.ulAudioLengthInMS/1000) {
                _ulPlaySecs=mmAudioHeader.mmXWAVHeader.XWAVHeaderInfo.ulAudioLengthInMS/1000;
                _ulPlayMsecs=mmAudioHeader.mmXWAVHeader.XWAVHeaderInfo.ulAudioLengthInMS;
              }
              else {
                _ulPlaySecs=mmAudioHeader.mmXWAVHeader.XWAVHeaderInfo.ulAudioLengthInBytes/
                  mmAudioHeader.mmXWAVHeader.WAVEHeader.ulAvgBytesPerSec;
                _ulPlayMsecs=_ulPlaySecs*1000;
              }
            }/* _somIsA()*/
          else
            {
              /* The file is a midi file. Get audio information using MCI commands. */
              unsigned char chrCommand[CCHMAXPATH];
              char retMsg[20];
              APIRET rc;
              ULONG ulTime;

              bIsMidi=TRUE;

              /* Prevent Timidity crash */
              if(globalHaveTimidity)
                break;

              /* open the file */
              sprintf(chrCommand,"open \"%s\"  type SEQUENCER alias wave%d SHAREABLE wait",fName,  somSelf);
              rc = mciSendString( chrCommand, retMsg, sizeof(retMsg), NULLHANDLE, 0);
              if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
                break;
              }

              /* Set time format */
              sprintf(chrCommand,"SET wave%d TIME FORMAT MILLISECONDS wait", somSelf);
              rc = mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
              if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
                /* close the file */
                sprintf(chrCommand,"close wave%d wait", somSelf);
                mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
                break;
              }

              /* Get midi info */
              sprintf(chrCommand,"STATUS wave%d LENGTH WAIT", somSelf);
              rc = mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
              if((rc & 0x0000ffff)!=MCIERR_SUCCESS) {
                /* close the file */
                sprintf(chrCommand,"close wave%d wait", somSelf);
                mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
                break;
              }
              ulTime=atoi(retMsg);
              //     HlpWriteToTrapLog("Midi-Time in ms: %d %s\n", ulTime, fName);

              if(ulTime/1000) {
                _ulPlaySecs=ulTime/1000;
                _ulPlayMsecs=ulTime;
              }
              else {
                _ulPlaySecs=1;
                _ulPlayMsecs=_ulPlaySecs*1000;
              }

              //              HlpWriteToTrapLog("Midi-Time ulPlaySecs: %d\n", _ulPlaySecs);
              sprintf(chrCommand,"STATUS wave%d NUMBER OF TRACKS WAIT", somSelf);
              rc = mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
              if((rc & 0x0000ffff)==MCIERR_SUCCESS) {
                _ulChannels=atoi(retMsg);
                //     HlpWriteToTrapLog("Midi-Tracks: %d %s %s\n", _ulChannels, fName, retMsg);
              }

              /* close the file */
              sprintf(chrCommand,"close wave%d wait", somSelf);
              mciSendString(chrCommand, retMsg, sizeof(retMsg), 0, 0);
            }/* else is MMMIDI */

          _ulFileSize=_wpQueryFileSize(somSelf);
          _bNeedSaving=TRUE;/* When the object is initialized the new instance data will be saved in wpObjectReady(). */

          sprintf(fName,"%d",_ulChannels);
          strncpy(_chrChannels, fName, sizeof(_chrChannels));
          _chrChannels[sizeof(_chrChannels)-1]=0;

          if(bIsMidi)
            strncpy(_chrSampleRate, "---", sizeof(_chrSampleRate));      
          else {
          sprintf(fName,"%d", _ulSampleRate);
          strncpy(_chrSampleRate, fName, sizeof(_chrSampleRate));          
          }
          _chrSampleRate[sizeof(_chrSampleRate)-1]=0;

          if(!_ulBitRate)
            strncpy(_chrBitRate, "---", sizeof(_chrBitRate));
          else {
            sprintf(fName,"%d",_ulBitRate);
            strncpy(_chrBitRate, fName, sizeof(_chrBitRate));
          }
          _chrBitRate[sizeof(_chrBitRate)-1]=0;

          if(bIsMidi)
            strncpy(_chrBPS, "---", sizeof(_chrBPS));
          else {
            sprintf(fName,"%d",_ulBPS);
            strncpy(_chrBPS, fName, sizeof(_chrBPS));
          }
          _chrBPS[sizeof(_chrBPS)-1]=0;
          
          sprintf(fName,"%02d:%02d",_ulPlaySecs/60, _ulPlaySecs%60);
          strncpy(_chrPlayTime, fName, sizeof(_chrPlayTime));
          _chrPlayTime[sizeof(_chrPlayTime)-1]=0;
          
          bContinue=TRUE;
          break;
        }/* for */
      }
      CATCH(AUDIO_WORKER)
        {
          SysWriteToTrapLog("\nTrap occured in %s, file %s, around line %d.\n",
                            __FUNCTION__, __FILE__, __LINE__);
          SysWriteToTrapLog("Audio file: %s\n\n",
                            fName);
        } END_CATCH;

        /* Hide status window */
        WinPostMsg(__get_hwndStatus(_CWMMDataFile), WM_APPTERMINATENOTIFY, 0, 0L);
        
        if(!bContinue)
          return (MRESULT)FALSE;

        /* This Message was posted from wpRestore(). It's not allowed to call
         wpSaveDeferred() from there. The object must be initilized! This is important when 
         creating objects from templates. So we wait for the object to be initialized.
         If it isn't initialized within 2s we quit. */
        ulLoop=0;
        while(!_wpIsObjectInitialized(somSelf) && ulLoop<40) {
          DosSleep(50);
          ulLoop++;
        }
        if(ulLoop<20)
          _wpSaveDeferred(somSelf);
        /* Now we have the audio info */
        _wpCnrRefreshDetails(somSelf);
        /*
          @@CHANGE 0.2.9

          Also refresh shadows in containers. For now we only support one shadow but that doesn't is a problem
          because after the first shadow the linked object has queried the audio data and every other shadow
          that will be awaked can use that info without ending here. Only problem may be the user opens a lot
          of folders with shadows and we are not fast enough but I don't care at the momen ;-).
         */
        if(pLinkObj!=NULLHANDLE && somIsObj(pLinkObj)) /* The check on NULLHANDLE is very fast while somIsObj() needs 
                                                          quite some time. So we check for a valid object only if we
                                                          can be quite sure we have an object (pointer!=NULLHANDLE). */
          _wpCnrRefreshDetails(pLinkObj);
        return (MRESULT) FALSE;
      }
    default:
      break;
    }

  return WinDefWindowProc( hwnd, msg, mp1, mp2);
}

